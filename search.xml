<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[对于springMVC的运行过程的理解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%AF%B9%E4%BA%8EspringMVC%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天又复习了一下springMVC的框架，又看了书上的解释，现在对springMVC运行原理做点总结，说的不好，请大佬们不要介意。 啥是springMVC？ Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不会直接处理请求。而是调用业务层的方法进行处理，而业务层调用持久层，通过Spring的依赖注入功能，这些bean被注入到控制器中。 springMVC是SSM中的s之一。springMVC中的组件 1、DispatcherServlet为前端控制器，它的作用相当于CPU，一切的工作活动都由这个前端控制器来控制。所有的请求都有经过它来统一分发。 2、HandlerMapping 为处理器映射器，为用户请求的url，能够完成客户请求到Controller映射。 。 3、HandlerAdapyer 为处理器适配器，找到对应controller。 4、ViewResolver 为视图解析器解析View对象，返回给前端的视图页面。springMVC原理图 springMVC的真正内部执行过程是这样的。web.xml DispatcherServlet是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项：（1）截获符合特定格式的URL请求。（2）初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。（3）初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。 对应web.xml文件 12345678910111213141516171819202122&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!-- 配置servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 加载SpringMVC配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 在启动tomcat的时候，服务器解析web.xml中的文件，取到前端控制器dispatcherServlet，其实前端控制器就是一个servlet，这里servlet-mapping标签配置的是我们前端控制器要拦截的的路径，这里的/表示所有的路径。init-param标签里面是需要初始化的文件，这里就初始化了springMVC.xml这个配置springMVC的文件。 一般我们还在web.xml中加入解决中文乱码的配置文件 12345678910111213&lt;!-- 解决中文乱码--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; springMVC.xml这个文件12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "&gt;&lt;!-- 扫描对应的包--&gt; &lt;context:component-scan base-package="com.spring"&gt;&lt;/context:component-scan&gt;&lt;!-- 视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;/bean&gt;&lt;!-- 映射处理器--&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping" abstract="true"/&gt;&lt;!-- 处理器适配器--&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter" abstract="true"/&gt; &lt;mvc:annotation-driven /&gt;&lt;!-- 静态资源--&gt; &lt;mvc:resources mapping="/css/*" location="resources/css/"/&gt; &lt;mvc:resources mapping="/js/*" location="resources/js/"/&gt; &lt;mvc:resources mapping="/images/*" location="resources/images/"/&gt;&lt;/beans&gt; 第一个点：扫描对应的包context:component-scan，以完成Bean创建和自动依赖注入的功能 。这里利用了spring的注入，注解注入。 第二个点：bean id=”internalResourceViewResolver” 视图解析器，用于渲染页面返回页面，第一个property指的是对应的文件夹下，第二个代表后缀。 mvc:annotation-driven 为开启springMVC框架的注解的支持-。 mvc:resources为配置静态资源，那些静态资源可以通过。在加载springMVC文件的时候这些都解析了。只要来一个请求就会直接执行。Controller 1234567891011121314151617package com.spring.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.UUID;@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test() t &#123; return "success"; &#125;&#125; 根据路径来执行每个方法。然后返回一个success.jsp，这里就经过了视图解析器，最终稿返回到前端页面（客户端）。]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>springMVC</tag>
        <tag>运行原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js原型链的世界]]></title>
    <url>%2F2019%2F08%2F02%2Fjs%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[js的继承关系不同意搞懂，原型链傻傻不明白，今天用通俗易懂的讲解和例子为大家呈现最简单的原型链理解。 原型链是什么鬼？能干啥？ 每一个类都有一个原型，而这个原型和对象实例之间又有十分微妙的关系。例如：下面的创建对象的代码。 1234function Person(name)&#123; this.name = name;&#125;var person = new Person("nan"); 实际上在函数的内部执行了这个：这里的注释部分实际上就是我们创建对象的时候，执行的函数，也是有返回值的。所以并不是用函数（类）创建对象就没有返回值。 12345678function Person(name)&#123; //var this = &#123; // __proto__:Person.prototype // &#125; this.name=name; // return this &#125; var person = new Person("nan"); 不知道大家看懂了没，注释部分是浏览器内部执行的，我们不需要写，这个是原理，而proto这个是对象的属性，跟我们平常用的是一样的，他也是和这个this.name之后的结果是平级的，都存储在this对象中。而Person.prototype就是我们所说的原型，这是一个对象，隶属于类的对象。 12345678function Person(name)&#123; //var this = &#123; // __proto__:Person.prototype， // name:"nan" // &#125; // return this &#125; var person = new Person("nan"); 而原型链就是很多个原型，形成的链式结构，先看一个代码： 12345678910111213141516Grand.prototype.lastname = "heihei";function Grand()&#123; this.say = 'en';&#125;var grand = new Grand();Father.prototype = grand;function Father()&#123; this.name = "hh" &#125;var father = new Father();Son.prototype = father;function Son()&#123; this.hobbit = "smoke" &#125;var son = new Son();console.log(son) 控制台结果结果： 这就是我们的链式结果，大家先了解，我们在下面会详细介绍这部分知识。 原型链的主要功能是体现在js对象的继承方面上的。 简单回顾下构造函数,原型和实例的关系：每一个构造函数（也就是咱们名字大写的函数function F(){}）都有一个原型对象（prototype）,原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.。 js对象有这么个有趣的规则:如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性。理解原型链 这里就以上面的代码为例：同时大家要明确，原型链脱离对象是没意义的。 如果每一个原型含有相同的属性名，那也是可以的，不过，任何方法在查找属性都是从son对象开始查找，看看有没有这个属性，如果有的话直接获取，没有再依次查找father、grand直到遍历完原型链。 至于这里为什么proto都叫Grand，是由于最上层是Grand.prototype中的contructor构造器是Grand__proto__和prototype的关系 proto属于对象属性，里面含有的是类.prototype，prototype是类属性。 例如： 1234function Person()&#123;&#125; var person = new Person(); console.log(person.__proto__ == Person.prototype); 这里是相同的，而且形成原型链的时候可以指定Person.prototype的对象。实际原型链分析1、简单类型 1234567891011Person.prototype = &#123; name : 'a', sayName : function()&#123; console.log(this.name) &#125;&#125;function Person()&#123; this.name = 'b';&#125;var person = new Person();person.sayName(); 1234567891011Person.prototype = &#123; name : 'a', sayName : function()&#123; console.log(this.name) &#125;&#125;function Person()&#123; // this.name = 'b';&#125;var person = new Person();person.sayName(); 将Person中的this.name注释掉，发现就是输出的是原型的值，这也再次验证了上面说的，对象查找属性是从原型链开始查找的，逐步向上查找。2、复杂类型12345678910111213141516171819Grand.prototype.lastname = "heihei";function Grand()&#123; this.say = 'en';&#125;var grand = new Grand();Father.prototype = grand;function Father()&#123; this.name = "hh" &#125;var father = new Father();Son.prototype = father;function Son()&#123; this.hobbit = "smoke" &#125;var son = new Son();console.log(son.hobbit);console.log(son.name);console.log(son.say);console.log(son.lastname); 这样也再再次验证了。利用实现对象的继承 实际上上述的例子就实现了上面的对象继承，但是对于这种情况：无法实现传参。 123456789101112Person.prototype.info = function()&#123; console.log("name:"+this.name+",age"+this.age+",grade:"+this.grade); &#125; function Person(name,age)&#123; this.name = name; this.age = age; &#125; Student.prototype = new Person(); function Student(name,age,grade)&#123; this.grade = grade &#125; var stu = new Student("戴",20,11); 这里的name和age都没有传入进去。我们可以输出一下。 1console.log(stu); 这里面的值都是undefined。有的人喜欢这样去修改。 123456789101112131415Person.prototype.info = function()&#123; console.log("name:"+this.name+",age"+this.age+",grade:"+this.grade); &#125; function Person(name,age)&#123; this.name = name; this.age = age; &#125; Student.prototype = new Person(); function Student(name,age,grade)&#123; this.grade = grade &#125; var stu = new Student(11); stu.name = "戴"; stu.age = 20; stu.info(); 第一眼看来，这是正确的，但是实际上这里个问题就是麻烦，不符合正常的面向对象的构造对象的步骤，繁琐。1console.log(stu) 这里实际上是再stu对象中，增加了两个实例属性。这也是不符合我们的要求的，我们想的是覆盖undefined。 最终继承代码，也是最牛叉的。 12345678910111213141516Person.prototype.info = function()&#123; console.log("name:"+this.name+",age"+this.age+",grade:"+this.grade); &#125; function Person(name,age)&#123; this.name = name; this.age = age; &#125; Student.prototype = new Person(); function Student(name,age,grade)&#123; Person.call(this,name,age); // Person.apply(this,[name,age]) this.grade = grade &#125; var stu = new Student("戴",20,11); stu.info(); console.log(stu); 利用了一个call或者apply就可以实现。最后一个例子（利于理解） 12345678910111213141516171819202122232425262728293031function Animal(age,sex)&#123; this.sex = sex; this.age = age; this.info = function()&#123; console.log("年龄:"+this.age+",性别:"+this.sex); &#125; &#125; Dog.prototype = new Animal(); function Dog(name,age,sex)&#123; this.name = name; Animal.call(this,age,sex); this.bark = function()&#123; console.log(this.name+"的叫声wangwangwang"); &#125; &#125; var dog = new Dog("hsq",2,'m'); dog.info(); dog.bark(); Cat.prototype = new Animal(); function Cat(name,age,sex)&#123; this.name = name; Animal.call(this,age,sex); this.bark = function()&#123; console.log(this.name+"的叫声miaomiaomiao"); &#125; &#125; var cat = new Cat("bsm",2,'f'); cat.info(); cat.bark();]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>原型链</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂的js闭包]]></title>
    <url>%2F2019%2F08%2F01%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84js%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包在js中是非常重要的一部分，也是可以说最难的一部分，这篇文章讲带你去理解闭包与、作用域链、执行期上下文的关系，带你去理解js中查找查找变量的底层原理。 1、闭包是什么鬼？ 当内部函数被保存到了外部时，将会生成闭包。闭包会导致原有的作用域链不释放，造成内存泄露。 如果i不知道作用域链是什么鬼，那么请看前两篇。12345678function outer()&#123; function inner()&#123; &#125; return inner;&#125;var demo = outer();demo(); 2、闭包是这么个东西 首先，在执行var demo = outer();之前（这个是一个函数调用），outer函数产生了一个执行期上下文，产生了一个作用域链。 执行后将inner函数给到了demo 1var demo = function inner()&#123; &#125; 再次执行的demo();之前，inner本身产生了一个执行期上下文，和一个新的作用域链，outer()。执行完他的作用域链就消失了。 最后执行，执行函数。3、举个栗子示例1123456789101112function add()&#123; var count = 0; function demo()&#123; count++; console.log(count); &#125; return demo;&#125;var counter = add();counter();counter();counter(); 如果不知道闭包这个概念，一定会认为是输出三个1； 我们来分析一下三个 counter()；第一个执行，这里通过count++，加加到作用域链中。输出1 然后执行 counter()，这里的 数据再次加一，之前说过，函数中所有查找变量和对数据的操作都是查找的作用域链。 同理，第三次。示例2123456789101112131415function test()&#123; var num = 100; function a()&#123; num++; console.log(num); &#125; function b()&#123; num--; console.log(num); &#125; return [a,b];&#125;var c = test();c[0]();c[1](); 这个和第一题也是同理示例3 1234567891011121314function eater()&#123; var food = ""; function a()&#123; console.log("i am eating" + food); food = ""; &#125; function b(myfood)&#123; food = myfood; &#125; return [a,b]; &#125; var eater1 = eater(); eater1[1]('banana'); eater1[0](); 这里的例子展示的是两个函数，两个作用域链，互不干扰。示例4 1234567891011121314function test()&#123; var arr = []; for(var i = 0;i &lt; 10;i++)&#123; arr[i] = function ()&#123; console.log(i + " "); &#125; &#125;; return arr; &#125; var myarr = test(); for(var j = 0;j &lt; 10;j++) &#123; myarr[j](); &#125; 如果不知道执行期上下文、作用域链、闭包的童鞋们一定会认为是输出0 - 9，但是结果： 我们来分析一下：这里面的for循环执行完之后是这样的i = 10；这里的要点在于arr[i] = function (){ }，这里输出的i是查找作用域链中的，在for循环中无法确定里面的值。作用域链： 更改代码为： 123456789101112131415function test()&#123; var arr = []; for(var i = 0;i &lt; 10;i++)&#123; (function (j)&#123; arr[j] = function ()&#123; document.write(j + " "); &#125; &#125;(i)); &#125; return arr;&#125;var myarr = test();for(var j = 0;j &lt; 10;j++)&#123; myarr[j](); &#125; 运行结果： (function(){})在test和arr[i]之间多加了一层的作用域。这样就可以正常输出了。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>作用域链</tag>
        <tag>scope</tag>
        <tag>执行期上下文</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js底层原理作用域和作用域链]]></title>
    <url>%2F2019%2F07%2F31%2Fjs%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[前几天刚刚整理的 JavaScript预编译（执行期上下文），这里需要提前明白上一篇文章，这篇文章也是为闭包铺垫理论知识。 1、作用域（[[scope]]） [[scope]]：每一个js函数都是一个对象，对象中有些属性我们可以访问，但是有些不可以，这些属性仅供js引擎存取，[[scope]]就是其中的一个。[[scope]]指的是我们所说的作用域（作用域链），其中存储了运行期期上下文的集合。每一个函数都有一个作用域。 运行期上下文：当函数执行的过程之前，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行对应执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行期上下文会被销毁。 看不懂概念不要紧，可以看下面的例子，然后看概念就会理解。 如果不知道执行期上下文的可以看：第二篇：JavaScript预编译（执行期上下文）2、作用域链 [[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。3、要知道 12345function Person()&#123;&#125;console.log(Person.name);console.log(Person.prototype); 这里的Person.name等就是可以访问的，但是Per’son.[[scope]]就是我们访问不到的。 这里每次调用都会产生一个新的AO对象。12345function test()&#123; &#125;test() -&gt; 产生一个AO&#123;&#125; 用完销毁test() -&gt; 产生一个AO&#123;&#125; 用完销毁 3、例子123456789function a()&#123; function b()&#123; var b = 234; &#125; var a = 123; b();&#125; var glob = 100; a(); a函数定义时，产生了一个[[scope]]，这里实际上只有一个GO，全局的作用域。 a在要执行之前，产生了一个执行期上下文。在这里，新创建的AO是作用域的顶端，我们在查找变量的时候就是沿着作用域链去查找变量，从顶端开始。这也就是为什么，在函数调用时，先查找自己是否含有这个属性，如果没有这个属性就去父级查找，这就是原理。这就是a函数的作用域链了。可以理解为[[scope]]为一个数组。函数本身的预编译形成AO永远是放在最顶端。 由于a函数的执行内部执行b()，所以b函数只在执行之前又产生了一个执行期上下文。所以b的作用域链直接基于a的作用域链。 b函数被创建时的作用域环境： b()执行之前进行预编译，形成的作用域链。 当b函数查找变量的时候，自顶向下查找变量。这里是为下一篇闭包铺垫理论知识。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>作用域链</tag>
        <tag>scope</tag>
        <tag>执行期上下文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS权重]]></title>
    <url>%2F2019%2F07%2F31%2FCSS%E6%9D%83%E9%87%8D%2F</url>
    <content type="text"><![CDATA[css在设置样式的时候，存在优先级的问题，比如设置了两个背景颜色，那么真正显示的究竟是哪一种颜色呢？ 一、问题提出？请问div的背景颜色为红色还是绿色呢？ 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="background-color: green;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 答案为绿色。为什么会是绿色呢？难道存在代码执行的先后的覆盖问题？请看第二个问题。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; &#125; #demo1&#123; background-color: red; &#125; .demo2&#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo2" id="demo1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; div的颜色为红色。当设置背景颜色的代码互换后div的背景颜色依然是红色。这说明并不是覆盖问题，读者可以自己试一试。 123456.demo2&#123; background-color: green;&#125;#demo1&#123; background-color: red;&#125; 二、问题的解释在css的样式中存在权重，权重最高的执行相关的代码。权值是256进制。| 相关属性 | 权值 | 相关样例 ||–|–|–|| !important | Infinity | #only{background-color: yellow!important;} ||行间样式|1000| p style = “” /p || id | 100 | #demo{} ||class、属性、伪类|10|.demo{} 、 、a:hover{}|| 标签、伪元素 | 1| div{} 、::after{} ||通配符|0|*{}|第一个问题中，由于行间样式的权值要比内联样式的权值要高，所以执行行间样式的代码。第二个问题中，由于id的权值要比class权值高，所以执行id的代码。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>css权重</tag>
        <tag>css优先级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[史上最好理解的Unicode编码讲解（Unicode的前世今生）]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%90%86%E8%A7%A3%E7%9A%84Unicode%E7%BC%96%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88Unicode%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[关于Unicode的由来，以及与utf-8、utf-16的关系、原理、计算、编码和解码。用最通俗易懂的方法讲解。 一、了解编码 在计算机中存储的数据都是01二进制的数据串，我们再电脑屏幕上看到的一切可视化的东西最终在计算机存储的都是01二进制串，现在看到我博客上的文字也是。 这里就需要一个映射关系，将我们看到的看到的字符、图片、视频转换成对应的二进制，存储到计算机中，以便于计算机能够识别。这就是我们要将的编码。 图片和视频首先会转换成字符流，然后按照编码转换成字节流，存储到计算机中。 举一个例子：在ASCLL码表中，字符’a‘对应的是97，二进制是01100001，如果我们在编辑器或者其他软件中输入字母a，按键盘a，那么输入法就会告诉操作系统，在计算机中调用97，然后就会显示a字符。 也就是说编码表在我们在计算机屏幕看到的数字和计算机底层之间架起了一个桥梁。至关重要！ 二、编码的历程1、开始 最早出现的是ASCLL码，是由美国人制定的，这种编码采用的是1个字节表示一个字符，也就是一个字符是八个二进制位，这里一共可以表示256个字符。起初，表示英文中所有的字符一共用了128位字符。事实上还剩下了一百多个字符空间。这128个字符中包含了数字、字母以及常用字符，例如：A是65，对应的二进制数为0100 0001。而且呢，这个128个字符只用了八位二进制数中的后七位，最前面的一位统一为0。 2、问题初现 但是很快就暴露出了问题，这128个字符表示英文没有任何问题，但是要是表示其他国家的语言就不够了。率先是欧洲决定利用起来前一位，这样就可以表示256个字符了，而紧接着又出现了一个问题，就是不同国家的同一个码点（八位二进制数）表示的符号可能不同，例如144 在阿拉伯人的 ASCII 码中是 گ，而在俄罗斯的 ASCII 码中是 ђ。 所以呢，最后人们在0-127号字符上面达成了一致，对于128 - 255号字符就尽情发挥了，这时候的码点还是一个字节。 3、再遇到波折 随着计算机的兴起，传入亚洲国家，亚洲国家有更多的字符需要存储，这样256个字符就放不下这些符号了，这时候人们决定用两个字节一共十六位，最多可以表示65535个字符。来存储全世界的字符。但是此时各个国家的编码还是不一样的。如ASCII、GB2312等。 4、程序员的噩梦 各种各样的编码方式成了系统开发者的噩梦，因为他们想把软件卖到国外，但是由于编码不同，一台计算机根本无法表示所有国家的编码。于是，他们提出了一个“内码表”的概念，可以切换到相应语言的一个内码表，这样才能显示相应语言的字母。在这种情况下，如果使用多语种，那么就需要频繁的在内码表内进行切换。这样依然很麻烦。 5、解决 最终，美国人决定设计一种标准方案来展示世界上所有语言中的所有字符，Unicode诞生了。Unicode 给所有的字符指定了一个数字用来表示该字符。规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。它的想法很简单，就是为每个字符规定一个用来表示该字符的数字，仅此而已。具体是怎样的对应关系，又或者说是如何进行划分的，就不是我们考虑的问题了， 三、Unicode 编码方案 Unicode 当然是一本很厚的字典，记录着世界上所有字符对应的一个数字。以汉字“汉”为例，它的 Unicode 码点是 0x6c49，对应的二进制数是 110110001001001，二进制数有 15 位，这也就说明了它至少需要 2 个字节来表示。可以想象，在 Unicode 字典中往后的字符可能就需要 3 个字节或者 4 个字节。 1、空间浪费？ 大家可以试想一下，有的字符需要两个字节、有的需要三个四个字节，那计算机如何去分辨该字节是几个字节的字符呢？大家第一个想到的可能是全部采用4个字节的编码，毕竟这个可以表示上亿个字符了。但是如果一个美国的新闻发布网站，全英文表示（前面已经说了代码单元也就是存储为一个字节就可以表示所有的英文字符），现在前面三个字节都是0，文件大小变成了之前的四倍或者三倍，这样浪费掉了大量的存储空间。 2、UTF系列编码什么鬼？ 为了较好的解决 Unicode 的编码问题， UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了。当然还有一个 UTF-32 的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，但是一般的字符两个字节就可以轻松解决了，只有一些其他小国家的特殊字符才采用UTF-32编码。 3、UTF-8编码 UTF-8 是一个非常惊艳的编码方式，漂亮的实现了对 ASCII 码的向后兼容，以保证 Unicode 可以被大众接受。 UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下： 对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。 对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。 编码规则如下： Unicode 十六进制码点范围 UTF-8 二进制 0000 0000 - 0000 007F 0xxxxxxx 0000 0080 - 0000 07FF 110xxxxx 10xxxxxx 0000 0800 - 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 - 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 4、插入一只广告 这里的除x外都是控制位，真正的表示位的只是x，第一个字节0xxxxxxx，可以容纳7个二进制位，第二个可以容纳11个二进制位，以此类推，然后计算左边的范围。 5、编码与解码 根据上面编码规则对照表，进行 UTF-8 编码和解码就简单多了。下面以汉字“汉”为利，具体说明如何进行 UTF-8 编码和解码。“汉”的 Unicode 码点是 0x6c49（110 1100 0100 1001），通过上面的对照表可以发现，0x0000 6c49 位于第三行的范围，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 11100110 10110001 10001001，转换成十六进制就是 0xE6 0xB7 0x89。 解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节。 UTF-16编码 在了解 UTF-16 编码方式之前，先了解一下另外一个概念——“平面”。 在上面的介绍中，提到了 Unicode 是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（2^16）字符，称为一个平面（plane）。目前，一共有 17 个（2^5）平面，也就是说，整个 Unicode 字符集的大小现在是 2^21。 最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 2^16-1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 U+010000 到 U+10FFFF。 基本了解了平面的概念后，再说回到 UTF-16。UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？ 这里有一个很巧妙的地方，在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。 辅助平面的字符位共有 2^20 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。 接下来，以汉字”𠮷”为例，说明 UTF-16 编码方式是如何工作的。 汉字”𠮷”的 Unicode 码点为 0x20BB7，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 0x20BB7 - 0x10000 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为0001000010 1110110111。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。U+D800 对应的二进制数为 1101100000000000，直接填充后面的 10 个二进制位即可，得到 1101100001000010，转成 16 进制数则为 0xD842。同理可得，低位为 0xDFB7。因此得出汉字”𠮷”的 UTF-16 编码为 0xD842 0xDFB7。 Unicode3.0 中给出了辅助平面字符的转换公式： 123H = Math.floor((c-0x10000) / 0x400)+0xD800L = (c - 0x10000) % 0x400 + 0xDC00 根据编码公式，可以很方便的计算出字符的 UTF-16 编码。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>unicode编码</tag>
        <tag>uft-8编码</tag>
        <tag>uft-16编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于浮点数丢失精度的原理]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%85%B3%E4%BA%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浮点数会存在精度丢失的现象，大很多金融的大项目中，都不去使用浮点数。因为这个数很危险，我们可以剖析一下原理。 1、前言首先我们必须要清楚 在计算机中所有的数值、代码、信息都是以01二进制存储的，也就是说我们输入的所有信息，最终都会表示成01二进制的形式。例如byte类型的 0000 1000表示的是整数8。然后我们要清楚 所有的整数类型转换成二进制，看如下代码： 12345//表示11的二进制数计算11 / 2 = 5 余 1 --&gt; 15 / 2 = 2 余 1 --&gt; 12 / 2 = 1 余 0 --&gt; 0 1 / 2 = 0 余 1 --&gt; 1 所有的小数转换成二进制：看如下代码： 1234567//0.1转换为二进制0.1 * 2 = 0.2 --&gt;00.2 * 2 = 0.4 --&gt;00.4 * 2 = 0.8 --&gt;00.8 * 6 = 1.6 --&gt;1//然后去掉10.6 * 2 = 1.2 --&gt;10.2 * 2 = 0.4 --&gt;0 这个是一直循环下去的，所以呢计算机无法精确表示0.1，这个数值而是无限接近近似表示。 所以11的二进制数是1011，这样开来所有的整数最后都会被1 / 2 = 0这样结束。 2、我们先来看这样的一段代码12345double dou = 234533464.456576564675d;System.out.println("234533464.456576564675的运行结果："+dou);float f = 997979759f;System.out.println("997979759的运行结果："+f);System.out.println("0.1+0.2的运行结果："+(0.2 + 0.1)); 结果是： 惊奇不惊奇，刺激不刺激？这种采用浮点数的方法，输出的结果就是错误的。前两位后面的精度丢失，最后一个表示的不准确。 同样再看另外一段代码123456float f1 = 20014999; double d1 = f1; double d2 = 20014999; System.out.println("f=" + f1); System.out.println("d=" + d1); System.out.println("d2=" + d2); 运行结果： 又是满满的疑问123double a = 0.3d;System.out.println(0.2d+0.1d);System.out.println(a); 我估计第三个直接刷新了好多人的三观，为啥直接存储就输出正确，运算就出错了呢？接下来我就围绕这几个问题对对大家一一解答。3、我们先了解一下浮点数在计算机中是如何存储的。 float（32位浮点数）在计算机中的表示形式。 浮点数存储都遵守IEEE754标准，具体的运算应该在计算机组成原理中会重点介绍，标准如下： 其中S表示该浮点数的正负，E代表阶码，M代表的是尾数。 一个十进制数可以表示为 : 例如：20.59375在计算机中存储为： 20.59375 = 10100.10011，这里的s = 0，E = 4 + 127 = 131 ，M = 01001001； 所以存储格式为0100 001 1010 0100 1100 0000 0000 0000。这里就是存储在计算机中的数据。 至于为什么要加127，这个是IEEE754标准规定的，但是在维基百科以及其他文献中也并没有直接说为什么是这样。 double（64位浮点数）在计算机中的表示形式。 同理这个和上面的是一样的。 实际上这个1.M表示的是比如1000.111这个数，小数点移动位为1.000111，在754标准下存储为000111位数，这么做相当于是能够多保存一位，所以float可以保存的尾数是24位（23），double为53位而不是（52）。4、我们首先来解决第二个问题 123float f1 = 20014999; double d1 = f; double d2 = 20014999; 刚才不是说所有的整数都不会丢失精度吗，这个这么不一样呢。这个实际上也是因为float保留的位数太小造成的。 我们来分析一下：先输出他们的二进制位数 123456789float f1 = 20014999; double d1 = f1; double d2 = 20014999;long l1 = Float.floatToIntBits(f1);long l2 = Double.doubleToLongBits(d1);long l3 = Double.doubleToLongBits(d2);System.out.println("f1=" + Long.toBinaryString(l1)); System.out.println("d1=" + Long.toBinaryString(l2)); System.out.println("d2=" + Long.toBinaryString(l3)); 这里遵循IEEE754标准，但是注意这里面没有符号位，这三种结果为什么不同，我们这就分析，首先我告诉大家d2的输出结果是正确的。其中前11位是阶码1000 0010 111= 1047，后面的0011 0001 0110 0111 1001 0111 0000 0000 0000 0000 0000 0000 0000便是尾数，所以1047 - 1023 = 24，所以这个数真正的结果就是（别忘了1.M）：1.0011 0001 0110 0111 1001 0111然后小数点向右移动24位，就是10011 0001 0110 0111 1001 0111 = 20014999； 我们再来看第一个我们对比着尾数1.00110001011001111001100就会发现这里的尾数要比1.001100010110011110010111少了一位，而且少的一位是1，所以进行舍入处理，进行进位变成了1.00110001011001111001100。这样就产生了误差。也就变成了20015000。大家要清楚这里不光是尾数的位数少了还有相应的进位处理。同时要记得这里面float只能保存24位小数，double可以保留53位。 第二个就不用说了，由于本身f是错的，所以呢，赋值给d1之后仍然是是错的。 第三个由于54尾尾数可以放得下该数值的二进制数，所以是正确的。 到此为止呢，大家要明确一个概念就是，如果保存的浮点数超过了，该类型的最大精度，那么就会产生是很大很严重的问题，而且存入计算机中就会是存储的错的。明确这一点之后也就产生了我们第三个问题（非常奇怪的问题），所以呢我们最后来说这个问题。5、解决第一个问题。 讲过第二个问题之后，第一个问题就非常好理解了，我们通过IEEE754的算法，可以得到这两个数的二进制表示形式，当用754标准去选取尾数的时候呢，就会截取掉一部分的尾数，造成精度丢失，其实原理是一样的。234533464.456576564675 = 2.34533464456576564675*e8,然后仍然是转换成754标准就失去了一些精度。具体的算法需要朋友们找相关的资料，这里不在赘述。6、最奇怪的问题第三个问题。1234567double a = 0.1d;double b = 0.2d;double c = a + b;System.out.println(a+&quot;的二进制数:&quot;+Long.toBinaryString(Double.doubleToLongBits(a)));System.out.println(b+&quot;的二进制数:&quot;+Long.toBinaryString(Double.doubleToLongBits(b)));System.out.println(c+&quot;的二进制数:&quot;+Long.toBinaryString(Double.doubleToLongBits(c)));System.out.println(0.3+&quot; 的二进制数:&quot;+Long.toBinaryString(Double.doubleToLongBits(0.3d))); 大家可以看到直接存储的0.3和计算之后出现的（数学上来说的0.3）在计算机中保存的二进制编码是不同的，原因就在于首先计算机中无法精确表示0.1和0.2，所以实际上a，b并不是真正的0.1和0.2，已经出现了误差，所以相加之后计算出来的值就是错的，也就是0.30000000000000004。那至于为什么能够出现直接存储就可以正常显示呢，是由于编译器优化的结果，在不计算的情况下，可以正常显示，但是没有任何意义，因为一旦参与计算或者比较大小，那么这个值就不代表数学意义上的0.1了。]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>浮点数精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript预编译（执行期上下文）]]></title>
    <url>%2F2019%2F07%2F28%2FJavaScript%E9%A2%84%E7%BC%96%E8%AF%91%EF%BC%88%E6%89%A7%E8%A1%8C%E6%9C%9F%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[很多人前端人员都知道变量提升这个概念，但是为什么会出现这样，很多人模棱两可。实际上在js中这叫做预编译，也叫做执行期上下文，在这里深度剖析一下它的底层原理。 预编译（又叫“执行期上下文”）一般来说，预编译与闭包、作用域链和闭包是密切相关的，好多人包括在企业开发的人都听说过一句话叫做变量提升和“函数声明整体提升”。这个就是预编译后的一个小结果，所以今天自己总结了一下。分为以下几个步骤来说。 大家先看看这段代码12console.log(a);var a = 1; 为什么变量的声明在输出的下面，却没有报错？值为什么是undefined？ 大家再看看下面这段代码1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; function test(a,b)&#123; console.log(a); var a = 'demo'; console.log(a); function a()&#123;&#125; console.log(a); var a = function ()&#123;&#125; console.log(a); console.log(b) var b = 1; &#125; test(1);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 大家看到这段代码是不是很震惊呢？形参、变量名、函数名都是“a”，那么输出的结果会是怎样呢？ 和大家想的一样吗？大家心里是不是有这么几个问题，前四个输出的都是a，为什么输出的结果不一样呢？而且b变量不是把1赋值给它了吗，为什么会是undefined？接下来咱们来讲讲什么是预编译（执行期上下文）。到最后大家就明白了。 预编译（‘执行期上下文’）预编译发生在函数执行之前。划重点了啊！！！！！ 这句话很重要，函数执行之前也就是在这段程序开始之前，浏览器对马上要执行的函数进行预编译！！预编译四部曲 创建AO对象 找形参和变量声明，将变量和形参作为AO属性名，值为undefined 将实参和形参相统一 在函数体里找到函数声明，值赋予函数体最后程序输出变量值的时候，就是从AO对象中拿。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>变量提升</tag>
        <tag>预编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>tags1</tag>
        <tag>tags2</tag>
      </tags>
  </entry>
</search>
