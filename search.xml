<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java：三大框架整合搭建SSM框架]]></title>
    <url>%2F2019%2F08%2F08%2FJava%EF%BC%9A%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[SSM框架整合了springMVC、spring、Mybatis三大框架。 1、SSM原理图 首先前端页面发送请求，然后通过前端控制器找到对应的Controller，Controller调用Service的方法，Service调用Dao层的方法，Dao方法对数据库操作，将查询的值返回到Controller进行处理。最后响应页面。 Controller、Service、Dao分别对应springMVC、spring、mybatis框架。这也是MVC三层模型的基本思想。 分别用spring去整合mybatis和springMVC。 2、SSM各文件的关系 由于这里的配置比较多，所以大家要明确这里的配置文件之间的关系。下面就一个一个来说如何配置。下面的配置可以结合这个图来看。 3、各配置文件web.xml文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载springMVC.xml文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:springmvc.xml classpath:applicationContext.xml &lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 解决中文乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 这里的web.xml文件时tomcat启动时，就加载的文件。一切的请求都由前端控制器支配，初始化时，加载springMVC.xml和applicationContext.xml文件。这里还有一个编码的配置器。 springMVC.xml文件12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "&gt; &lt;!-- 开启注解扫描--&gt; &lt;context:component-scan base-package="com.maven.controller"/&gt; &lt;!-- 开启springMVC框架的注解的支持--&gt; &lt;mvc:annotation-driven/&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping" /&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt;&lt;!-- 释放静态资源--&gt; &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt; 注解扫描需要用base-package指定我们要扫描的包路径，一般指向controller。 开启springMVC框架的注解的支持，是固定写法。 internalResourceViewResolver视图解析器，两个property配置的是文件的路径以及后缀名。 映射处理器和处理器适配器一般直接加上就可以了。 释放静态资源，可以这样写，当然还有另一种写法&lt;mvc:resource..。指定对应的静态资源。html、css、js之类的。 applicationContext.xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;!-- dao层配置文件开始--&gt;&lt;!-- 配置数据库连接池--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/maven?useUnicode=true&amp;amp;characterEncoding=utf8" /&gt; &lt;property name="user" value="root" /&gt; &lt;property name="password" value="111111" /&gt; &lt;/bean&gt;&lt;!-- 配置sqlSession对象的工厂--&gt; &lt;bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- mappering 配置文件 --&gt; &lt;/bean&gt; &lt;!-- 配置accountDao接口所在的包--&gt; &lt;bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactoryBean"/&gt; &lt;property name="basePackage" value="com.maven.dao"/&gt; &lt;/bean&gt;&lt;!-- dao层配置文件结束--&gt;&lt;!-- service层配置文件开始--&gt;&lt;!-- 组件注解扫描--&gt; &lt;context:component-scan base-package="com.maven.service"/&gt;&lt;!-- aop面向切面编程,切面就是切入点和通知的组合--&gt;&lt;!-- 配置事务管理器--&gt; &lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置事务通知--&gt; &lt;tx:advice id="advice" transaction-manager="dataSourceTransactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="save*" propagation="REQUIRED"/&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" read-only="true"/&gt;&lt;!-- 全局扫描--&gt;&lt;!-- &lt;tx:method name="*" propagation="REQUIRED"/&gt;--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;!-- 配置切面--&gt; &lt;aop:config&gt; &lt;aop:pointcut id="pointcut" expression="execution(* com.maven.service.Impl.*.*(..))"/&gt; &lt;aop:advisor advice-ref="advice" pointcut-ref="pointcut"/&gt; &lt;/aop:config&gt;&lt;!-- service层配置文件结束--&gt;&lt;/beans&gt; 数据库的配置信息、配置sqlSession对象的工厂、配置accountDao接口所在的包，这里都可以依据自己的数据库信息修改。 然后是开启spring注解扫描、配置事务管理器、配置事务通知、配置切面。 完整项目目录 IUserDao接口 这里只写了一个方法测试。 1234567package com.maven.dao;import com.maven.domain.User;public interface IUserDao &#123; public User findAllById(int id);&#125; 这里面配置的方法是IUserDao.xml 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.maven.dao.IUserDao"&gt; &lt;select id="findAllById" parameterType="int" resultType="com.maven.domain.User"&gt; select * from user where id = #&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt; User实体类12345678package com.maven.domain;public class User &#123; private int id; private String name; private int age; //省略get和set方法&#125; IUserService12345678package com.maven.service;import com.maven.domain.User;import org.springframework.stereotype.Service;public interface IUserService &#123; public User findAllById(int id);&#125; serServiceImpl1234567891011121314151617package com.maven.service.Impl;import com.maven.dao.IUserDao;import com.maven.domain.User;import com.maven.service.IUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements IUserService &#123; @Autowired private IUserDao userDao; public User findAllById(int id) &#123; return userDao.findAllById(id); &#125;&#125; UserController12345678910111213141516171819202122232425package com.maven.controller;import com.maven.domain.User;import com.maven.service.IUserService;import com.maven.service.Impl.UserServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;@Controller@RequestMapping("/user")public class UserController &#123; @Autowired private IUserService userService; @RequestMapping("/test") public String findDetail(Model model) &#123; User user = userService.findAllById(1); System.out.println(user); model.addAttribute("", user); return "success"; &#125;&#125; 测试类，这个大家可以自己写。jsp12345678910111213141516&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2019/8/7 Time: 13:29 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="user/test"&gt;点击我&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2019/8/7 Time: 13:28 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;success&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 最后 小伙伴们有什么问题可以留言。]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>springMVC</tag>
        <tag>Mybatis</tag>
        <tag>spring</tag>
        <tag>SSM框架搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven高级之jar包冲突、标签]]></title>
    <url>%2F2019%2F08%2F07%2Fmaven%E9%AB%98%E7%BA%A7%E4%B9%8Bjar%E5%8C%85%E5%86%B2%E7%AA%81%E3%80%81%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[回顾基础、解决jar包冲突的三种方式、以及maven的标签讲解。 1、maven基础 maven是一个项目管理工具。依赖管理 maven对项目中的jar包的管理过程，传统工程我们直接把jarb包放置在项目中。 maven工程真正的jarb包放置在仓库中，项目中只用放置jar包的坐标。仓库的种类 本地仓库：在我们本机上的maven仓库。 远程仓库【私服】：一般是公司的仓库。 中央仓库：类似于阿里源或者https://mvnrepository.com/。仓库之间的关系当我们启动一个maven工程时，maven工程会通过pom文件中jar包的坐标去本地仓库找对应的jar包下载默认情况下，如果本地仓库没有对应的jar包，maven工程会自动去中央仓库下载jar包到本地仓库。在公司中，如果本地没有对应的jar包，会先从私服下载jar包。如果私服中没有jar包，可以从中央仓库下载，也可以从本地上传。maven命令 一键构建：maven自身集成了tomcat插件，可以对项目j进行编译、测试、打包、安装发布等操作。 maven常用命令：clean清理、compile编译、test测试、package打包、install安装、deploy打包上传到私服。 maven三套生命周期：清理生命周期、默认生命周期、站点生命周期。修改web.xml 我们在IDEA或者eclipse创建一个maven工程后，这个工程的web.xml是需要我们修改的，这个并不符合我们原本的项目，我们需要需要添加一些约束。12345678910&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;/web-app&gt; 2、解决maven导入jar包冲突直接依赖和传递依赖 直接依赖：项目中直接导入的jar包，就是该项目的直接依赖包。 传递依赖：项目中没有直接导入的jar包，可以通过项目直接依赖jar包传递到项目中去。 这里同时引入了两个包，但是这个包里有一个传递依赖spring-bean，它的版本跟直接依赖包是相同的，也就说有两个spring-bean依赖包，一个是5.0.2.RELEASE，另一个是4.3.7.RELEASE。那么这样就产生了冲突，究竟是哪一个导入了项目呢。还是都导入了项目？ 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 大家可以看看项目存在的包：项目中引入的是5.0.2.RELEASE版本的。为什么呢？解决方法：第一声明优先原则 哪个jar包的坐标靠上的位置，这个jar包就是先声明的。先声明的jar包坐标下的依赖包，可以优先进入项目 。通过直接依赖 直接引入spring-bean的jar包。直接依赖要比传递依赖的优先级高。1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 直接排除法（工作中常用） 当我们要排除某一个jar包下的依赖包，在配置&lt;exclusion&gt;时，内部可以不用写版本号。默认版本号和直接依赖包是一样的。123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 3、pom.xml内的标签添加tomcat插件123456789&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 锁定jar包版本（只是锁定，不是引入） maven工程是可以分父子依赖关系的。凡是依赖别的项目后，拿到别的项目的依赖包，都属于传递依赖。 比如：当前A项目，被B项目所依赖，那么我们A项目中所有 jar包都会传递B项目中。B项目开发者，如果再在B项目中导入一套ssm框架的jar包，对于B项目是直接依赖。那么直接依赖的jar包，就会把我们A项目传递过去的jar包覆盖掉。 为了防止以上情况的出现，我们可以把A项目中主要的jar包的坐标锁住，那么其他依赖该项目的项目中，即便是有同名jar包直接依赖，也无法覆盖 。 12345678&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 添加依赖 在这里添加所需要依赖的jar包的坐标，然后maven就会去本地仓库获取。123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 统一管理jar包版本12345678910&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;&lt;/properties&gt;]]></content>
      <categories>
        <category>maven高级</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>解决jar包冲突</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java方法参数的传递方式：按值转递]]></title>
    <url>%2F2019%2F08%2F05%2Fjava%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%8C%89%E5%80%BC%E8%BD%AC%E9%80%92%2F</url>
    <content type="text"><![CDATA[在java中是采用按值调用的方式给方法传递参数，有些小伙伴还是分不清按值调用和按引用调用，傻傻分不清。本文讲解两种方式的区别。举了几个例子，带你理解透彻java按值调用。 按值传递和按引用传递 java程序是按值传递的，在C或者C++中引用数据类型都是按引用传递的，这就导致了不同的结果。 定义一个类和方法123456package obj;public class User &#123; public String firstName; private String lastName;&#125; 1234567891011public swap(User u1,User u2)&#123; User temp = u1; u1 = u2; u2 = temp;&#125;public swap(int num1,int num2)&#123; int temp = num1; num1 = num2; num2 = temp;&#125; 按值传递（java中只有按值传递）12345public static void main(String[] args) &#123; int a = 1; int b = 2; swap(user1,user2);&#125; 按值调用的结果都是局部变量销毁，不影响外边的变量。在java中即使传入的是对象引用参数也是一样的。按引用传递（例如c++，这里只是用java代码举例子）12345public static void main(String[] args) &#123; User user1 = new User(); User user2 = new User(); swap(user1,user2);&#125; 这里面X01000和X01111都是指的地址。最后的数据是会发生改变的。3、看一个小例子，加深印象 123int n = 10,m = 20;exchange(n,m);System.out.println(n + " " + m); 12345public static void exchange(int a, int b) &#123; int temp = a; a = b; b = temp;&#125; 结果 ：这个没啥好说的了。 12345678int[] i = &#123; 1, 2 &#125;;int[] j = &#123; 3, 4 &#125;;exchange(i, j);System.out.println(Arrays.toString(i));System.out.println(Arrays.toString(j));exchange1(i, j);System.out.println(Arrays.toString(i));System.out.println(Arrays.toString(j)); 1234567891011public static void exchange(int[] a, int[] b) &#123; int[] temp = a; a = b; b = temp;&#125;public static void exchange1(int[] a, int[] b) &#123; int temp = a[0]; a[0] = b[0]; b[0] = temp;&#125; 结果：由于java是按值调用，所以不会改变原来的数组的引用。但是如果改变的是数组中的值是可以改变的。 12345String s1 = "123";String s2 = "456";exchange(s1,s2);System.out.println(s1);System.out.println(s2); 12345public static void exchange(String a, String b) &#123; String temp = a; a = b; b = temp;&#125; 结果：字符串还是不变的，按值调用。 1234567891011User u1 = new User();u1.firstName = "guoshuai";User u2 = new User();u2.firstName = "taoge";exchange(u1,u2);System.out.println(u1.firstName);System.out.println(u2.firstName); exchange1(u1,u2);System.out.println(u1.firstName);System.out.println(u2.firstName); 1234567891011public static void exchange(User a, User b) &#123; User temp = a; a = b; b = temp;&#125;public static void exchange1(User a, User b) &#123; String temp = a.firstName; a.firstName = b.firstName; b.firstName = temp;&#125; 结果：第一个方法不会改变引用，按值调用。第二个方法，改变的是对象的值，跟改变数组的值是一样的。可以改变。]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>参数的传递方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解：java的三种工厂模式]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%9Ajava%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式！！！ 1、简单工厂模式描述 简单工厂的定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类。看下面的例子。 Person接口 代码12345package factory;public interface Fruit &#123; public void draw();&#125; Chinese类 123456789package factory;public class Apple implements Fruit &#123; public void draw() &#123; System.out.println("苹果真香"); &#125;&#125; English类 123456789package factory;public class Orange implements Fruit &#123; public void draw() &#123; System.out.println("橘子巨香"); &#125;&#125; PersonFactory工厂类 1234567891011121314package factory;public class Factory &#123; public static Fruit getPerson(String fruitName)&#123; if(fruitName == null) return null; if( fruitName.equalsIgnoreCase("Apple")) return new Apple(); else if( fruitName.equalsIgnoreCase("Orange")) return new Orange(); else return null; &#125;&#125; 测试类 1234567891011package factory;public class Main &#123; public static void main(String[] args) &#123; Fruit apple = Factory.getPerson("Apple"); Fruit orange = Factory.getPerson("Orange"); apple.draw(); orange.draw(); &#125;&#125; 结果： 缺点1 扩展性差（我想增加另一个水果，除了新增一个水果类，还需要修改工厂类方法）2 不同的产品需要不同额外参数的时候 不支持。 适用场景其实由定义也大概能推测出其使用场景，首先由于只有一个工厂类，所以工厂类中创建的对象不能太多，否则工厂类的业务逻辑就太复杂了，其次由于工厂类封装了对象的创建过程，所以客户端应该不关心对象的创建。总结一下适用场景：（1）需要创建的对象较少。（2）客户端不关心对象的创建过程。 2、工厂方法描述 由于简单工厂模式只适用于固定不变的几个产品，但实际情况确是我们需要动态的增加产品。所以就出现了工厂方法（简单工厂模式的改进版），创建一个工厂接口。如果出现新的水果类，我们只需要增加实现工厂接口的类和实现水果接口的类，不必改变原有工厂的代码。 代码 工厂接口 12345package factory;public interface IFactory &#123; public Fruit getFruit(String fruitName);&#125; 工厂实现类 1234567891011121314package factory;public class Factory &#123; public Fruit getFruit(String fruitName)&#123; if( fruitName == null) return null; if( fruitName.equalsIgnoreCase("Apple")) return new Apple(); else if( fruitName.equalsIgnoreCase("Orange")) return new Orange(); else return null; &#125;&#125; 水果的代码和上面的是一样的。 测试类 123456789101112package factory;public class Main &#123; public static void main(String[] args) &#123; Factory factory = new Factory(); Fruit apple = factory.getFruit("Apple"); apple.draw(); Fruit orange = factory.getFruit("Orange"); orange.draw(); &#125;&#125; 适用场景（1）客户端不需要知道它所创建的对象的类。例子中我们不知道每个图片加载器具体叫什么名，只知道创建它的工厂名就完成了床架过程。（2）客户端可以通过子类来指定创建对应的对象。以上场景使用于采用工厂方法模式。 3、抽象工厂模式 有了工厂方法模式，可以解决很大部分创造类的问题，但还有一个现实中的问题，有一个工厂的话可以创造一系列产品 ，如果工厂方法模式的话就需要创造一系列的工厂来完成这种效果，如何来解决这个问题呢？对于一些系列工厂问题就可以用一个可以系列描述的工厂来表示，每个工厂都有系列的的生产方法，也就是说是生产工厂的工厂。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//抽象工厂类abstract class Factory&#123; abstract ProductA create(); abstract ProductB create();&#125;//工厂Mclass FactoryM&#123; public ProductA create()&#123; return new ProductA(); &#125; public ProductB create()&#123; return new ProductB(); &#125;&#125;//工厂Nclass FactoryM&#123; public ProductA create()&#123; return new ProductA(); &#125; public ProductB create()&#123; return new ProductB(); &#125;&#125;//产品父类abstract class Product&#123;&#125;//产品子类Aabstract class ProductA extends Product&#123;&#125;//产品子类Babstract class ProductB extends Product&#123;&#125;//系列M产品class ProductAM extends ProductA&#123;&#125;class ProductBM extends ProductB&#123;&#125;//系列N产品class ProductAN extends ProductA&#123;&#125;class ProductBN extends ProductB&#123;&#125;public class App&#123; public static void main(String[] args)&#123; Product p; Factory f=new FactoryA() //消费者类中创造A产品 p=f.create(); &#125;&#125; 适用场景（1）和工厂方法一样客户端不需要知道它所创建的对象的类。（2）需要一组对象共同完成某种功能时。并且可能存在多组对象完成不同功能的情况。（3）系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
        <tag>工厂方法模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js关于this那点事]]></title>
    <url>%2F2019%2F08%2F05%2Fjs%E5%85%B3%E4%BA%8Ethis%E9%82%A3%E7%82%B9%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[相信好多小伙伴对js中this很头疼，所以在这里总结了一下js中this的指向。 this的四种情况 this 的指向一共有四种情况，记住理解就可以玩遍js的this。 函数预编译过程this –&gt; window 全局作用域 this –&gt; window call/apply 可以改变this的指向 obj.fun()；谁调用指向谁 第一种情况：函数预编译过程this –&gt; window 这种情况多数指的是纯函数调用前预编译的过程，在作用域链上的this指向。大家可以看下面的图： 可以看如下代码 123456789function demo()&#123; this.demo1 = function()&#123; console.log(this === window); &#125; demo1();&#125;demo();var d = new demo();d.demo1(); 第一个输出为true，而第二个new函数也相当于是调用函数输出true。这就证明了this指向的是window，而第三个为false是由于对象调用this指向的是对象，所以this.demo1是一个对象属性，输出为false。 第二种情况：全局作用域 this –&gt; window 在全局作用域下，this是指向window的。 1console.log(this == window); 第三种情况：call/apply 可以改变this的指向 大家要明白call和apply的区别，只有传递参数不同。12345678910function Person(name)&#123; this.name = name; this.info = function()&#123; console.log(this.name); &#125; &#125; var name = "bbb"; var p = new Person("aaa"); p.info(); p.info.call(window); p.info();这个是属于咱们的第四种情况，对象谁调用就指向谁，输出。p.info.call(window)，指向window，输出bbb。第四种情况：谁调用指向谁 new对象之后谁调用指向谁（这个对象）。123456789function Person(name)&#123; this.name = name; this.info = function()&#123; console.log(this.name); &#125; &#125; var name = "bbb"; var p = new Person("aaa"); p.info(); 实际上还有第五种特殊情况（ES6箭头函数） 在箭头函数中，永远指向箭头函数this总是代表包含箭头函数的上下文。 这里面new Demo()是必须的，如果只是普通的调用函数，那么包含箭头函数的执行期上下文只有一个就是window对象，因为只有对象才可以用this。12345function Demo()&#123; var f = () =&gt; this; console.log(f() === window); &#125; var demo = new Demo(); 对比着来看普通函数： 12345function Demo()&#123; var f = function()&#123;return this;&#125; console.log(f() === window); &#125; var demo = new Demo(); 一个简单的例子（坏坏的表情） 如果你理解了这个例子，那么就证明你吃透了this。 12345678910111213141516171819var name = "222";var a = &#123; name : "111", say : function ()&#123; console.log(this.name); &#125;&#125;var fun = a.say;fun();a.say();var b = &#123; name : "333", say : function (fun)&#123; fun();//走预编译 &#125;&#125;b.say(a.say);b.say = a.say;b.say(); 看到这个结果是不是有点小懵。 我们来慢慢分析一下，var fun = a.say;实际上是将a.say这个函数赋值给fun，但是fun的是是属于window全局的，所以呢调用this.name输出222。属于第二种情况。 a.say();这个好说this指向的是obj对象，输出111。属于第四种情况。 b.say(a.say);将a.say这个函数放到b.say的环境下调用，实际上属于预编译过程，属于第一个情况。输出222。 b.say = a.say;替换b.say。 b.say();执行，返回b对象中的name为333。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>this指向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis基础]]></title>
    <url>%2F2019%2F08%2F04%2FMybatis%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[复习了一下mybatis的知识点，篇幅可能有一些长。里面有关于mybatis的配置文件、resultMap标签、多表查询、一对一、一对多、对多一、延迟加载、缓存的知识点。 1、一个简单的Mybatis程序首先先看dao层的IUserDao 该层是持久层。里面有一个接口，用于查询存在一些查询的方法。123456package com.mybatis.dao;import com.mybatis.domain.User;import java.util.List;public interface IUserDao &#123; List&lt;User&gt; findAll();&#125; 再看domain层的User 这里面是一个类，这个类用于存放与数据库表对应的属性，也就是咱们说的ORM ，对象关系映射 1234567891011package com.mybatis.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; //省略get、set和toString方法&#125; 接着看resources层的SqlMapConfig.xml 这里是配置整个数据库的信息，这里面除了配置数据库的信息外，还要配置每一个dao层执行sql语句的文件。 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--mybatis主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt;&lt;!-- 配置mysql环境--&gt; &lt;environment id="mysql"&gt;&lt;!-- 配置事务类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;&lt;!-- 配置数据源（连接池）--&gt; &lt;dataSource type="POOLED"&gt;&lt;!-- 配置数据库的基本信息--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="111111"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每一个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="com/mybatis/dao/IUserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; IUserDao.xml是具体配置哪个接口的配置文件 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mybatis.dao.IUserDao"&gt; &lt;select id="findAll" resultType="com.mybatis.domain.User"&gt; select * from users &lt;/select&gt;&lt;/mapper&gt; 测试类1234567891011121314151617181920public class MybatisTest &#123; public static void main(String[] args)throws Exception &#123;// 1、读取配置文件 InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");// 2、创建SqlSessionFactory工厂 SqlSessionFactoryBuilder factoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = factoryBuilder.build(in);// 3、使用工厂生产SqlSession对象 SqlSession session = factory.openSession();// 4、使用SqlSession创建Dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class);// 5、使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user:users)&#123; System.out.println(user); &#125;// 6、释放资源 session.close(); &#125;&#125; 2、Mybatis中resultMap标签和sql标签的设置 IUserDao.xml其中的mapper标签中的namespace属性指的就是持久层中的接口，这里的sql语句都是对应这个接口中的方法，也就是指定了命名空间。在这里resultMap标签是查询结果的列名和实体类的属性名的对应关系，也就是说我们类中的属性名不一定和数据库中的保持一致，其中property配置的就是类中的属性名，column设置的就是数据库中表的字段名。在sql语句的标签中之前的，resultType变成了resultMap。sql标签中直接写的是就是sql语句，这个可以有效的避免重复的写sql相同代码，如果要引用sql标签中内容，在对应的语句中需要引用Include标签，具体的可以看下面的代码。 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mybatis.dao.IUserDao"&gt;&lt;!-- 配置，查询结果的列名和实体类的属性名的对应关系--&gt; &lt;resultMap id="userMap" type="com.mybatis.domain.User"&gt;&lt;!-- 主键字段对应--&gt; &lt;id property="userId" column="id"&gt;&lt;/id&gt;&lt;!-- 非主键字段对应--&gt; &lt;result property="userName" column="username"&gt;&lt;/result&gt; &lt;result property="userAddress" column="address"&gt;&lt;/result&gt; &lt;result property="userSex" column="sex"&gt;&lt;/result&gt; &lt;result property="userBirthday" column="birthday"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;sql id="defaultUser"&gt; select * from users &lt;/sql&gt;&lt;!-- 查询所有--&gt; &lt;select id="findAll" resultMap="userMap"&gt; &lt;include refid="defaultUser"&gt;&lt;/include&gt; &lt;/select&gt; &lt;select id="findById" parameterType="INT" resultMap="userMap"&gt; select * from users where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 3、Mybatis的CRUD IUserDao.xml配置文件如下： 这里的数据库表的字段和类的属性名称要一样，否则不能识别，如果想要改名字，可以用resultMap 。1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mybatis.dao.IUserDao"&gt; &lt;!--&lt;resultMap id="" type=""&gt; &lt;id property="" column=""&gt;&lt;/id&gt; &lt;result property="" column=""&gt;&lt;/result&gt; &lt;/resultMap&gt;--&gt;&lt;!-- 查询所有--&gt; &lt;select id="findAll" resultType="com.mybatis.domain.User"&gt; select * from users &lt;/select&gt;&lt;!-- 保存用户--&gt; &lt;insert id="saveUser" parameterType="com.mybatis.domain.User" &gt; insert into users(username,address,sex,birthday)values (#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;); &lt;/insert&gt;&lt;!-- 更新用户--&gt; &lt;update id="updateUserById" parameterType="com.mybatis.domain.User"&gt; update users set username=#&#123;username&#125;,address=#&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; where id=#&#123;id&#125;; &lt;/update&gt;&lt;!-- 删除用户--&gt; &lt;delete id="deleteUserById" parameterType="java.lang.Integer"&gt; delete from users where id=#&#123;id&#125;; &lt;/delete&gt;&lt;/mapper&gt; 4、Mybatis的模糊查询以及其它操作IUserDao.xml配置文件如下： 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mybatis.dao.IUserDao"&gt;&lt;!-- 保存用户--&gt; &lt;insert id="saveUser" parameterType="com.mybatis.domain.User" &gt; &lt;!--保存后返回id值--&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into users(username,address,sex,birthday)values (#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;); &lt;/insert&gt; &lt;!-- 模糊查询--&gt; &lt;select id="findByName" parameterType="string" resultType="com.mybatis.domain.User"&gt; &lt;!--select * from users where username like "%$&#123;value&#125;%";--&gt; select * from users where username like #&#123;username&#125;; &lt;/select&gt;&lt;!-- 查询总用户数--&gt; &lt;select id="findTotalUser" resultType="int"&gt; select count(id) from users; &lt;/select&gt;&lt;/mapper&gt; 4、多表联合查询之一对一数据库表 用户表users 账户表account，其中账户表的uid为外键，指向的是用户表的主键id我们首先来看两个实体类，对应着两张表 User类 123456public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; Account类：这里需要注意的是，在这里定义了一User的类。用于查询当前账户所属的用户信息。 12345public class Account implements Serializable &#123; private Integer id; private Integer uid; private String money; private User user; 查看咱们的主要配置文件：IAccountDao.xml在之前的文章中提到过resultMap这个标签，但是对于多表查询我们还需要嵌套一个association标签。因为我们主要查询的是账户信息，其次是附带的用户信息，所以将用户信息放在association标签内。其中的property就是咱们在Account类中定义的属性。接着就是SQL语句select u.*,a.id as aid,a.uid,a.money from account a,users u where u.id = a.uid。我们首先将两张表分别取别名，然后条件是id与uid相等，之后我们先查询出用户的所有信息，然后查询出账户的信息，哪张表放在前面都行。 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mybatis.dao.IAccountDao"&gt;&lt;!-- 定义封装account和user的resultMap--&gt; &lt;resultMap id="accountUserMap" type="com.mybatis.domain.Account"&gt; &lt;id property="id" column="aid"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt;&lt;!-- 一对一关系映射，配置封装user的内容--&gt; &lt;association property="user" column="uid"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;!-- 查询所有--&gt; &lt;select id="findAll" resultMap="accountUserMap"&gt; select u.*,a.id as aid,a.uid,a.money from account a,users u where u.id = a.uid &lt;/select&gt;&lt;/mapper&gt; 5、多表联合查询之一对多数据库表 用户表users 账户表account，其中账户表的uid为外键，指向的是用户表的主键id我们首先来看两个实体类，对应着两张表 1、User类 12345678public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; // 一对多关系映射，主表实体应该包含所属从表的实体的集合 private List&lt;Account&gt; accounts; 2、Account类：这里需要注意的是，在这里定义了一User的类。用于查询当前账户所属的用户信息。 1234public class Account implements Serializable &#123; private Integer id; private Integer uid; private String money; 查看咱们的主要配置文件：IUserDao.xml 这里与一对一查询不同的是在resultMap标签内嵌套了一个collection标签而不是association标签，这里的collection表示的是一个集合。这里需要注意一下ofType这个属性，这个属性表示的是这个集合中的成员的类型。如果没有别名的话，必须要用全限定类名。对于这里用的sql语句select * from users u left outer join account a on u.id = a.uid。采用左外查询方式，这个查询的好处是左边的user表会全部查出。 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mybatis.dao.IUserDao"&gt;&lt;!-- 定义User的resultMap--&gt; &lt;resultMap id="userAccountMap" type="com.mybatis.domain.User"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;collection property="accounts" ofType="com.mybatis.domain.Account"&gt; &lt;id property="id" column="aid" &gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;!-- 查询所有--&gt; &lt;select id="findAll" resultMap="userAccountMap"&gt; select * from users u left outer join account a on u.id = a.uid &lt;/select&gt; &lt;select id="findById" parameterType="INT" resultType="com.mybatis.domain.User"&gt; select * from users where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 6、多表联合查询之多对多数据库表 1、用户表 2、角色表 3、中间表其中中间表的两个外键分别指向另外两个表的主键id，uid指向User中的id，rid指向role中的id 我们首先来看两个实体类，对应着两张表（无中间表） 1、User类 123456public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; 2、Role类 12345 private Integer roleId; private String roleName; private String roleDesc;// 多对多的关系映射，一个角色可以赋予多个用户 private List&lt;User&gt; users; 查看咱们的主要配置文件：IRoleDao.xml 这里除了sql语句外，其余的都在之前的博客中提到过相关的配置标签的作用，这里不在强调。重点说一下sql语句。 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mybatis.dao.IRoleDao"&gt; &lt;resultMap id="roleMap" type="com.mybatis.domain.Role"&gt; &lt;id property="roleId" column="rid"&gt;&lt;/id&gt; &lt;result property="roleName" column="role_name"&gt;&lt;/result&gt; &lt;result property="roleDesc" column="role_desc"&gt;&lt;/result&gt; &lt;collection property="users" ofType="com.mybatis.domain.User"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username" &gt;&lt;/result&gt; &lt;result property="address" column="address" &gt;&lt;/result&gt; &lt;result property="sex" column="sex" &gt;&lt;/result&gt; &lt;result property="birthday" column="birthday" &gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="roleMap"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from role r left outer join user_role ur on ur.rid =r.id left outer join users u on ur.uid = u.id &lt;/select&gt;&lt;/mapper&gt; 首先呢，我们必须通过角色表和中间表查询相关的信息组成一张新表：用 SELECT * FROM role r LEFT OUTER JOIN user_role ur ON ur.rid =r.id得到如下的表： 大家可以看到在这个新表中，存在uid也就是指向我们用户表，然后将这个新表在与用户表联合左外查询便可得出结果： 这样就完成了多对多，由于新表中有重复的内容，所以我们改一下语句就是上面提到的7、延迟加载 在之前的文章一对多中，当我们有一个用户，他又一百个账户。（1）在查询用户时，要不要把关联的账户信息查询出来？（2）在查询账户时，要不要把关联的用户信息查询出来？ 对于第一个问题，我们应该是什么时候需要查询账户信息，才查询。没必要每次查询用户信息都把账户信息也查询出来。因为如果每次都查询出账户信息，对我们的内存开销是很大的，而且每次查询也都不一定用到账户信息。 对于第二个问题，我们就可以在查询账户信息的时候查询出关联的用户信息，因为我们如果只是单纯的账户信息没有说明用户是谁，这对于我们来说是不友好的。也没什么意义，所以在每次查询账户信息的时候都要显示出关联的用户信息。 延迟加载和立即加载 第一个问题其实就是延迟加载。第二个问题就是立即加载。延迟加载 在真正的使用数据时才发起查询，不用的时候不查。按需加载（懒加载）。 立即加载 不管用不用，只要一调用方法，马上发起查询。 四种对应的表关系中的加载 四种表 关系：一对一，一对多，多对一，多对多。 一对多、多对多：通常情况下，我们都是采用延迟加载。 多对一、一对一：通常情况下，我们都是采用立即加载。实现一对一的延迟加载这里的项目结构和https://blog.csdn.net/weixin_44588495/article/details/91556447里面的大部分内容是一样的，我们只需要更改一些配置信息。 更改IAccountDao.xml的配置信息这里将association标签中的内容全部删除，添加了一个select属性，select属性指向的是IUserDao接口的findById方法，也就是说执行这个sql语句后，就会执行findById这个方法，其中入口参数就是column中的uid这个值。 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mybatis.dao.IAccountDao"&gt;&lt;!-- 定义封装account和user的resultMap--&gt; &lt;resultMap id="accountUserMap" type="com.mybatis.domain.Account"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt;&lt;!-- 一对一关系映射，配置封装user的内容 select 属性指定的内容，查询用户的唯一标识 column 属性指定的内容，用户根据id查询时，所需要的参数的值--&gt; &lt;association property="user" column="uid" javaType="com.mybatis.domain.User" select="com.mybatis.dao.IUserDao.findById"&gt;&lt;/association&gt; &lt;/resultMap&gt;&lt;!-- 查询所有--&gt; &lt;select id="findAll" resultMap="accountUserMap"&gt; select * from account &lt;/select&gt;&lt;/mapper&gt; 更改SqlMapConfig.xml中的信息在这里添加两条setting标签配置信息。根据mybatis的文档http://www.mybatis.org/mybatis-3/zh/configuration.html#settings需要设置这两个属性。才能开启延迟加载。 1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;!-- 配置参数--&gt; &lt;settings&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;/settings&gt;&lt;/configuration&gt; 运行结果未调用获取账户信息的方法。 在MybatisAccountTest中调用1234567public void testFindAll() throws Exception&#123; List&lt;Account&gt; accounts = accountDao.findAll(); for (Account a:accounts)&#123; System.out.println("-----------------------"); System.out.println(a ); &#125; &#125; 调用获取信息的方法 在MybatisAccountTest中调用 12345678public void testFindAll() throws Exception&#123; List&lt;Account&gt; accounts = accountDao.findAll(); for (Account a:accounts)&#123; System.out.println("-----------------------"); System.out.println(a ); System.out.println(a.getUser()); &#125; &#125; 实现一对多的延迟加载这里的项目结构和https://blog.csdn.net/weixin_44588495/article/details/91556447里面的大部分内容是一样的，我们只需要更改一些配置信息。这里面的道理和一对一是一样的。只不过改的是collection标签内的属性。 更改IUserDao.xml 1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mybatis.dao.IUserDao"&gt; &lt;collection property="accounts" ofType="com.mybatis.domain.Account" select="com.mybatis.dao.IAccountDao.findAccountByUid" column="id"&gt;&lt;/collection&gt;&lt;/mapper&gt; IAccountDao接口：这里多增加了一个findAccountByUid方法 12345678public interface IAccountDao &#123; /** * 查询所有的Account * @return */ List&lt;Account&gt; findAll(); List&lt;Account&gt; findAccountByUid(Integer uid);&#125; IAccountDao.xml中需要增加一条方法配置信息 123&lt;select id="findAccountByUid" resultType="com.mybatis.domain.Account" parameterType="Integer"&gt; select * from account where uid = #&#123;uid&#125;&lt;/select&gt; SqMapConfig.xml文件和一对一是一样的。 运行结果：未调用获取账户信息的方法。 在MybatisTest中调用 1234567public void testFindAll() throws Exception&#123; List&lt;User&gt; users = userDao.findAll(); for (User user:users)&#123; System.out.println("--------------------------------------"); System.out.println(user); &#125; &#125; 调用获取信息的方法 在MybatisTest中调用 12345678public void testFindAll() throws Exception&#123; List&lt;User&gt; users = userDao.findAll(); for (User user:users)&#123; System.out.println("--------------------------------------"); System.out.println(user); System.out.println(user.getAccounts()); &#125; &#125; 这样就起到了该调用的时候调用，不用浪费多余的内存空间。 8、缓存 缓存 存在与内存中的临时数据。为什么使用缓存？ 减少和数据库的交互次数，提高执行的效率。什么样的数据能使用缓存 经常查询且不经常改变的 数据的正确与否对最终结果影响不大的什么样的数据不适用于缓存 经常改变的数据 数据的正确与否对最终结果影响很大的 例如：商品的库存，银行的汇率，股市的牌价 一级缓存 它指的是Mybatis中SqlSession对象的缓存，当我们执行查询之后，查询的结果同时会存入到SqlSession一块区域中，该区域的一个结构是Map结构。当我们再次查询同样的数据，mybatis会先去sqlsession中查询是否有，有的话直接拿来用。当SqlSession对象关闭时，或者清空缓存，mybatis的一级缓存也就消失了。 代码查看一级缓存 表结构 1234567891011121314151617181920212223242526272829303132public class MybatisTest &#123; private InputStream in; private SqlSession session; private IUserDao userDao; private SqlSessionFactory factory; @Before public void init() throws Exception &#123; this.in = Resources.getResourceAsStream("SqlMapConfig.xml"); SqlSessionFactoryBuilder factoryBuilder = new SqlSessionFactoryBuilder(); System.out.println(in); this.factory = factoryBuilder.build(in);// this.session = factory.openSession(true); this.session = factory.openSession(); this.userDao = session.getMapper(IUserDao.class); &#125; @After public void destory() throws IOException &#123; session.commit(); this.in.close(); this.session.close(); &#125; @Test public void testCache()&#123; User user1 = userDao.findById(8); System.out.println(user1); session.clearCache(); User user2 = userDao.findById(8); System.out.println(user2); System.out.println(user1 == user2); &#125;&#125; 执行完testCache方法后，结果如下：两个user对象是一样的，说明第一次从数据库中读取后，第二次直接拿的是session的一级缓存。 当我们把testCache的方法改成如下两钟时 12345678public void testCache()&#123; User user1 = userDao.findById(8); System.out.println(user1); session.clearCache(); User user2 = userDao.findById(8); System.out.println(user2); System.out.println(user1 == user2); &#125; 12345678910public void testCache()&#123; User user1 = userDao.findById(8); System.out.println(user1); session.close(); session = factory.openSession(); userDao = session.getMapper(IUserDao.class); User user2 = userDao.findById(8); System.out.println(user2); System.out.println(user1 == user2); &#125; 此时已经将缓存session关闭或者清空缓存，结果如下：此时两个User对象不同，说明是从数据库钟两次读取的结果。 一级缓存如何实现数据同步的呢？一级缓存是SqlSession范围的缓存，当调用SqlSession的修改、添加、删除，commit()，close()等方法时，就会清空一级缓存。这样如果更新了数据，就自动清空缓存，下一次读取的时候就在数据库中读取内容。 二级缓存 它指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。 二级缓存的使用步骤 第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置） 第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置） 第三步：让当前的操作支持二级缓存（在Select标签中配置） 代码查看二级缓存 SqlMapConfig.xml添加setting标签 1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--mybatis主配置文件--&gt;&lt;configuration&gt;&lt;!-- 配置参数--&gt; &lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;/settings&gt;&lt;/configuration&gt; IUserDao.xml添加一个cache标签 ，select标签中添加useCache=”true” 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.mybatis.dao.IUserDao"&gt; &lt;cache/&gt; &lt;select id="findById" parameterType="INT" resultType="com.mybatis.domain.User" useCache="true"&gt; select * from users where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类：sqlSession1.close();其中这个时关闭一级缓存对二级缓存的影响。 1234567891011121314public void testCache()&#123; SqlSession sqlSession1 = factory.openSession(); IUserDao userDao1 = sqlSession1.getMapper(IUserDao.class); User user1 = userDao1.findById(8); System.out.println(user1); sqlSession1.close(); SqlSession sqlSession2 = factory.openSession(); IUserDao userDao2 = sqlSession2.getMapper(IUserDao.class); User user2 = userDao2.findById(8); System.out.println(user2); sqlSession2.close(); System.out.println(user1 == user2); &#125; 运行结果：如果有日志的话，会看到该两次查询，只从数据库中查询了一次结果，然后从缓存中拿取。 user1 与 user2不相同的原因是，我们在数据库中存储的不是一个对象，而是一组数据，可以理解为json格式的数据，当有请求拿缓存中的数据时，直接将数据给他，然后创建出一个新的对象出来。所以虽然是从缓存中拿取，但是两次的对象肯定是不同的。这一点和一级缓存不同，一级缓存在缓存中存储的就是一个对象。有一个请求缓存过来时，直接用一个引用指向该对象。]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring框架基础]]></title>
    <url>%2F2019%2F08%2F04%2Fspring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[复习了一下spring的知识点，篇幅可能有一些长。里面有关于IOC控制反转、DI注入、和AOP面向切面编程。 1、IOC和DI配置bean 直接用在配置文件中用bean标签 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;!-- 把创建的对象交给Spring 这种方法用于默认构造函数 --&gt; &lt;bean id="accountDao" class="com.spring.dao.Impl.IAccountDaoImpl"&gt;&lt;/bean&gt; &lt;bean id="accountService" class="com.spring.service.Impl.IAccountServiceImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 通过类路径，读取配置文件创建对象。 12345678910public class Client &#123; public static void main(String[] args) &#123; //获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //根据id获取bean对象// IAccountServiceImpl accountService = (IAccountServiceImpl) ac.getBean("accountService"); IAccountService accountService = ac.getBean("accountService",IAccountService.class); accountService.saveAccount(new Account()); &#125;&#125; bean对象的作用范围 bean对象的作用范围默认情况下，bean是单例的，但是如果我们想把它改成多例的，怎么办？bean标签的scope属性：作用：用于指定bean的作用范围取值：singleton：单例的（默认值）prototype：多例的request：作用于web应用的请求范围。session：作用于web应用的会话范围。global-session：作用于集群环境的会话范围（全局会话范围），当不是集群时，他就是session1&lt;bean id="accountDao" class="com.spring.dao.Impl.IAccountDaoImpl" scope=""&gt;&lt;/bean&gt; DI 依赖注入 当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明。依赖中的维护称为DI。这里就像Person类中的name和age，一样。对于进入IOC之后的对象，需要进行初始化，用的就是DI。能注入的数据：基本类型和String、其他的bean类型（在配置文件中或者注解配置过的bean）、复杂类型/集合类型经常变化的数据不适合注入。注入的方式和：使用构造函数提供、使用set方法提供、使用注解提供使用构造函数标签使用：constructor-arg标签出现的位置：bean标签内部标签中的属性 type：用于指定 要注入数据的数据类型，该数据类型也是构造函数中某个或者某些参数类型 index：用于指定要注入数据构造函数中指定索引位置的参数赋值。索引位置从0开始 name： 用于指定构造函数中指定指定名称参数赋值 value：用于指定基本类型数据 ref：用于指定其他bean类的数据优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。IAccountServiceImpl类 1234567891011121314151617181920212223package com.spring.service.Impl;import com.spring.dao.Impl.IAccountDaoImpl;import com.spring.domain.Account;import com.spring.service.IAccountService;import java.util.Date;public class IAccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public IAccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void saveAccount(Account account) &#123; System.out.println("service保存" +name+ "," +age+"," + birthday); &#125;&#125; bean.xml 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;!-- spring中的依赖注入 --&gt;&lt;!-- 构造函数注入--&gt; &lt;bean id="accountService" class="com.spring.service.Impl.IAccountServiceImpl" &gt; &lt;constructor-arg name="name" value="test"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="age" value="12" &gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt;&lt;/beans&gt; 使用set方法注入（常用）标签使用：property标签出现的位置：bean标签内部标签中的属性 name： 用于指定注入时所调用的set方法名称 value：用于指定基本类型数据 ref：用于指定其他bean类的数据优势：在创建对象时没有明确的限制，可以直接使用默认构造函数弊端：如果有某个成员变量必须有值，则获取对象有可能set方法没有执行1234567891011121314151617181920212223242526272829package com.spring.service.Impl;import com.spring.dao.Impl.IAccountDaoImpl;import com.spring.domain.Account;import com.spring.service.IAccountService;import java.util.Date;public class IAccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public void saveAccount(Account account) &#123; System.out.println("service保存" +name+ "," +age+"," + birthday); &#125;&#125; bean.xml 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;!-- spring中的依赖注入 --&gt;&lt;!-- 构造函数注入--&gt; &lt;bean id="accountService" class="com.spring.service.Impl.IAccountServiceImpl" &gt; &lt;property name="name" value="test"&gt;&lt;/property&gt; &lt;property name="age" value="12" &gt;&lt;/property&gt; &lt;property name="birthday" ref="nono"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="nono" class="java.util.Date"&gt;&lt;/bean&gt;&lt;/beans&gt; 复杂类型的注入/集合类型的注入bean.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;!-- spring中的依赖注入 --&gt;&lt;!-- 构造函数注入--&gt; &lt;bean id="accountService" class="com.spring.service.Impl.IAccountServiceImpl" &gt; &lt;property name="array" &gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="array" &gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="map" &gt; &lt;map&gt; &lt;entry key="key1" value="value1"&gt;&lt;/entry&gt; &lt;entry key="key2"&gt; &lt;value&gt;value2&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="propertyies"&gt; &lt;props&gt; &lt;prop key="key1"&gt;value1&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2、基于注解的IOC和DI分类： 用于创建对象他们的作用就和在xml配置文件中编写一个&lt;bean&gt;标签的实现功能是一样的。 用于注入数据他们的作用就和在xml配置文件中的&lt;bean&gt;标签中写一个&lt;property&gt;标签的作用是一样的。 用于改变作用范围他们的作用集合在bean标签中使用scope属性实现的功能是一样的。 和生命周期有关他们的作用就和在bean标签中使用init-method和destory-method是一样的IOC注解 @Component：作用：用于把当前的类对象存入Spring容器中。属性：value用于指定bean的id。当我们不写的时候，它的默认值是当前的类名，且首字母小写。bean.xml文件 这里需要用到context这个名称空间 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 告知spring在创建容器的时候要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为context名称空间和约束中。--&gt; &lt;context:component-scan base-package="com.spring"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 类 这里采用用accountService作为id 12345678@Component(value = "accountService")public class IAccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void saveAccount() &#123; System.out.println("保存"); &#125;&#125; 测试类 当扫描xml文件的时候就自动给创建了类对象 12345678910public class Client &#123; public static void main(String[] args) &#123; //获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //根据id获取bean对象// IAccountServiceImpl accountService = (IAccountServiceImpl) ac.getBean("accountService"); IAccountService accountService = ac. getBean("accountService",IAccountService.class); accountService.saveAccount(); &#125;&#125; @Controller：一般用于表现层 @Service：一般用在业务层 @Repository：一般用在持久层 以上三个注解他们的作用和属性与@Component是一摸一样。 他们三个是spring框架为我们提供明确的三层使用的注解，使我们对三层对象更加清晰的。DI注解 Autowired：作用：自动按类型注入，只要容器有唯一的bean对象类型和要注入的变量类型匹配，就可以成功注入。如果ioc容器中没有任何bean类型和要注入的变量类型匹配，则报错。如果ioc容器中有多个类型匹配时，那么它首先找到对应接口的实现类，然后根据变量名=IOC容器中的id去寻找答案出现的位置：可以是变量上，也可以是方法上。细节：在使用注解注入时，set方法就不是必须的了 123456789@Service("accountService")public class IAccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 如果ioc容器中有多个类型匹配时，且对应的变量名也不匹配对应容器中的值时，@Autowire解决不了 @Qualifier作用：在按照类中注入的基础上再按照名称注入。它给类成员注入时，不能单独使用，再给方法参数注入时可以。属性：value用于指定注入bean的id 123456789@Service("accountService")public class IAccountServiceImpl implements IAccountService &#123; @Autowired @Qualifier("accountDao") private IAccountDao accountDao; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; Resource作用：直接按照在bean标签中使用的id注入。他可以独立使用属性：name：用于指定bean的id 12345678@Service("accountService")public class IAccountServiceImpl implements IAccountService &#123; @Resource(name="accountDao") private IAccountDao accountDao; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 以上三个注解只能注入其他bean类型的数据，而基本类型的String类型无法使用上述注解实现。另外集合类型的注入只能通过XML来实现。 Value：用于注入基本类型和String类型的数据属性：value用于指定数据的值。他可以使用spring中的SpEl(Spring的EL表达式)SpEl的写法：${表达式} 12345678@Repository("accountDao")public class IAccountDaoImpl implements IAccountDao &#123; @Value(value="1") private int id; public void saveAccount() &#123; System.out.println("保存" + id); &#125;&#125; 用于改变作用范围他们的作用就和在bean标签中使用scope属性实现的功能是一样的 Scope作用：用于指定bean的作用范围属性：value 指定范围的值。常取值：singleton、prototype默认是singleton123456789@Service("accountService")@Scope("prototype")public class IAccountServiceImpl implements IAccountService &#123; @Resource(name="accountDao") private IAccountDao accountDao; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 3、AOP面向切面编程（基于配置文件） 作用：在程序运行期间，不修改源码的基础上，对已有的方法增强 优势：减少重复代码、提高开发效率、维护方便 我们想的是在每个方法前都打印日字基本代码（1）IAccountService接口 1234567package com.spring.service;public interface IAccountService &#123; void saveAccount(); void updateAccount(int i); int deleteAccount();&#125; （2）AccountService类 123456789101112public class AccountService implements IAccountService &#123; public void saveAccount() &#123; System.out.println("执行保存"); &#125; public void updateAccount(int i) &#123; System.out.println("执行更新"); &#125; public int deleteAccount() &#123; System.out.println("执行删除"); return 0; &#125;&#125; （3）Logger类 12345678public class Logger &#123; /** * 用于打印日志，计划让其在切入点方法执行之前执行（切入点方法就是业务层方法） */ public void printLog()&#123; System.out.println("记录日志"); &#125;&#125; （4）main类 1234567public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService accountService = (IAccountService) ac.getBean("accountService"); accountService.saveAccount(); &#125;&#125; 配置bean.xml文件 1.把通知beans也交给spring来管理 使用aop:config标签表明aop的配置 使用aop:aspect标签配置切面，id：是给切面提供一个唯一标识，ref：是给定通知类的bean的id 在aop:apect标签内使用对应的标签配置通知的类型 aop:before前置通知，pointcut:用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强 切入点表达式：execution(表达式)，表达式：访问修饰符 返回值 包名.包名.类名.方法名（参数列表）123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="accountService" class="com.spring.service.Impl.AccountService"&gt;&lt;/bean&gt; &lt;bean id="logger" class="com.spring.utils.Logger"&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;!-- 配置切面--&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt; &lt;!-- 配置通知的类型，并且建立通知方法和切入点的方法名关联--&gt; &lt;aop:before method="printLog" pointcut="execution(public void com.spring.service.Impl.AccountService.saveAccount())"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 切入点表达式的写法： 标准写法：public void com.spring.service.impl.AccountServiceImpl.saveAccount()全通配写法 ：* * 。。。\ (。。) 这里的。为一个点访问修饰符可以省略：void com.spring.service.impl.AccountServiceImpl.saveAccount()返回值使用通配符：* com.spring.service.impl.AccountServiceImpl.saveAccount()包名可以使用通配符：* *.*.*.*.AccountServiceImpl.saveAccount()包名可以使用。。表示当前包及其子包：* *。。AccountServiceImpl.saveAccount()类名和方法名：* *。。*.*()参数列表：可以直接写数据类型：基本数据类型直接写名称 int，引用类型写包名.类名的方式，java.lang.String。可以使用通配符表示任意类型的数据，但是必须有参数：* *。。*.*(*)可以使用。。表示有无参数均可，有参数可以是任意类型。 实际开发中的写法： 切到业务层实现类下的所有方法： * com.spring.service.impl.*.*(。。)；四种常用通知类型Logger类这里只需要修改两个文件。 12345678910111213141516171819202122232425262728293031package com.spring.utils;public class Logger &#123; /** * 用于打印日志，计划让其在切入点方法执行之前执行（切入点方法就是业务层方法） */ /** * 前置通知 */ public void beforePrintLog()&#123; System.out.println("前置通知before记录日志"); &#125; /** * 后置通知 */ public void afterReturnPrintLog()&#123; System.out.println("后置通知afterReturn记录日志"); &#125; /** * 异常通知 */ public void afterThrowPrintLog()&#123; System.out.println("异常通知before记录日志"); &#125; /** * 最终通知 */ public void afterPrintLog()&#123; System.out.println("最终通知after记录日志"); &#125;&#125; bean.xml 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="accountService" class="com.spring.service.Impl.AccountService"&gt;&lt;/bean&gt; &lt;bean id="logger" class="com.spring.utils.Logger"&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;!-- 配置切面--&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt;&lt;!-- 前置通知--&gt; &lt;aop:before method="beforePrintLog" pointcut="execution(* com.spring.service.*.*(..))"&gt;&lt;/aop:before&gt;&lt;!-- 后置通知--&gt; &lt;aop:after-returning method="afterReturnPrintLog" pointcut="execution(* com.spring.service.*.*(..))"&gt;&lt;/aop:after-returning&gt;&lt;!-- 异常通知--&gt; &lt;aop:after-throwing method="afterThrowPrintLog" pointcut="execution(* com.spring.service.*.*(..))"&gt;&lt;/aop:after-throwing&gt;&lt;!-- 最终通知--&gt; &lt;aop:after method="afterPrintLog" pointcut="execution(* com.spring.service.*.*(..))"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 执行：异常通知只有在方法异常的情况下才会被执行，他和最终通知只能执行一个。 我们还可以用切入点表达式标签，id属性用于指点表达式唯一标识。expression属性用于指定表达式的内容。 此时该标签写在aop:aspect标签内部只能当前切面使用，它还可以写在aop:aspect外面，此时就变成了所有切面可用。这样就得放在所有aop:aspect标签之前。 123456789101112131415 &lt;aop:config&gt; &lt;!-- 配置切面--&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt;&lt;!-- 前置通知--&gt; &lt;aop:before method="beforePrintLog" pointcut-ref="pt"&gt;&lt;/aop:before&gt;&lt;!-- 后置通知--&gt; &lt;aop:after-returning method="afterReturnPrintLog" pointcut-ref="pt"&gt;&lt;/aop:after-returning&gt;&lt;!-- 异常通知--&gt; &lt;aop:after-throwing method="afterThrowPrintLog" pointcut-ref="pt"&gt;&lt;/aop:after-throwing&gt;&lt;!-- 最终通知--&gt; &lt;aop:after method="afterPrintLog" pointcut-ref="pt"&gt;&lt;/aop:after&gt; &lt;aop:pointcut id="pt" expression="execution(* com.spring.service.*.*(..))"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 环绕通知增加xml语句 12345678 &lt;aop:config&gt; &lt;!-- 配置切面--&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt; &lt;aop:around method="arroundLog" pointcut-ref="pt"&gt;&lt;/aop:around&gt; &lt;aop:pointcut id="pt" expression="execution(* com.spring.service.*.*(..))"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 增加logger类语句 123public void arroundLog()&#123; System.out.println("环绕通知"); &#125; 执行：这里没有打印saveAccount方法里面的打印输出 问题：当我们配置了环绕通知后，切入点方法没有执行，而通知方法执行了。 分析：需要有明确的切入点方法的调用。 解决：Spring框架为我们提供了一个接口，ProceedingJoinPoint。该接口y有一个方法，proceed()。此方法相当于明确调用切入点方法。该接口可以作为环绕通知方法的参数，在程序执行时，Spring框架会为我们提供该接口的实现类供我们使用。 配置在rtValue = pjp.proceed(args);之前的方法就是前置通知，在之后就时后置通知，在catch里面就是异常通知，在finally就是最终通知。它是Spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方法。123456789101112131415161718192021222324252627package com.spring.utils;import javafx.beans.binding.ObjectExpression;import org.aspectj.lang.ProceedingJoinPoint;/** * 提供公共方法 */public class Logger &#123; public Object arroundLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try &#123; Object[] args = pjp.getArgs(); System.out.println("前置通知"); rtValue = pjp.proceed(args); System.out.println("后置通知"); return rtValue; &#125; catch (Throwable throwable) &#123; System.out.println("异常通知"); throwable.printStackTrace(); &#125;finally &#123; System.out.println("最终通知"); &#125; System.out.println("环绕通知"); return null; &#125;&#125; 4、基于注解的AOP 在配置文件钟加入扫描注解和扫描AOP的配置。12&lt;context:component-scan base-package="com.spring" &gt;&lt;/context:component-scan&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 配置AOP信息对实现类添加注解，保证扫描包的时候该对象进入IOC容器 12@Service("accountService")public class AccountService implements IAccountService &#123; 12@Component("logger")public class Logger &#123; logger类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.spring.utils;import javafx.beans.binding.ObjectExpression;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * 提供公共方法 */@Component("logger")@Aspect//表示当前类是一个切面类public class Logger &#123; @Pointcut("execution(* com.spring.service.*.*(..))") private void pt()&#123;&#125; /** * 前置通知 */ @Before("pt()") public void beforePrintLog()&#123; System.out.println("前置通知before记录日志"); &#125; /** * 后置通知 */ @AfterReturning("pt()") public void afterReturnPrintLog()&#123; System.out.println("后置通知afterReturn记录日志"); &#125; /** * 异常通知 */ @AfterThrowing("pt()") public void afterThrowPrintLog()&#123; System.out.println("异常通知before记录日志"); &#125; /** * 最终通知 */ @After("pt()") public void afterPrintLog()&#123; System.out.println("最终通知after记录日志"); &#125; /** * 环绕通知 */ //@Around("pt()") public void arroundLog(ProceedingJoinPoint pjp)&#123; System.out.println("环绕通知"); &#125;&#125; 执行：直接使用这四个注解的方式它的调用顺序是有问题的。 使用环绕通知：执行四种通知 123456789101112131415161718@Around("pt()") public Object arroundLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try &#123; Object[] args = pjp.getArgs(); System.out.println("前置通知"); rtValue = pjp.proceed(args); System.out.println("后置通知"); return rtValue; &#125; catch (Throwable throwable) &#123; System.out.println("异常通知"); throwable.printStackTrace(); &#125;finally &#123; System.out.println("最终通知"); &#125; System.out.println("环绕通知"); return null; &#125; 执行：这样的顺序就没问题了 对于注解开发，更建议大家使用环绕通知，而不是四种注解的方式。同时我们也可以修改为全注解的方式。用注解的配置类代替bean.xml文件。bean.xml文件的信息如下： 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;context:component-scan base-package="com.spring" &gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 新建一个SpringConfiguration类 12345@Configuration@ComponentScan(basePackages = "com.spring")@EnableAspectJAutoProxypublic class SpringConfiguration &#123;&#125; 修改test类 class Test &#123;123456 public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); IAccountService accountService = (IAccountService) ac.getBean(&quot;accountService&quot;); accountService.saveAccount(); &#125;&#125; 执行： 5、jdbcTemplate的使用请看https://blog.csdn.net/weixin_44588495/article/details/93852840]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMVC基础知识]]></title>
    <url>%2F2019%2F08%2F03%2FspringMVC%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[复习了一下springMVC的知识点，随便总结了一下，几乎涵盖了所有springMVC的基础知识。篇幅可能有一些长。 1、简单搭建一个springMVC项目目录 引入所需要的依赖 这里我们采用maven工程去管理我们所需要的jar包。在pom.xml中引入我们的依赖。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;!-- 锁定版本号--&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置web.xml 这里面配有前端控制器和加载springMVC的配置文件。同时我们一般配置解决中文乱码。12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!-- 配置servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 加载SpringMVC配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; springMVC.xml文件 这里需要配置扫描对应的controller注解、配置视图解析器、配置映射处理器、配置处理器适配器、开启注解扫描、过滤静态资源等。12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "&gt;&lt;!-- 扫描对应的包--&gt; &lt;context:component-scan base-package="com.spring"&gt;&lt;/context:component-scan&gt;&lt;!-- 视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;/bean&gt;&lt;!-- 映射处理器--&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping" abstract="true"/&gt;&lt;!-- 处理器适配器--&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter" abstract="true"/&gt; &lt;mvc:annotation-driven /&gt;&lt;!-- 静态资源--&gt; &lt;mvc:resources mapping="/css/*" location="resources/css/"/&gt; &lt;mvc:resources mapping="/js/*" location="resources/js/"/&gt; &lt;mvc:resources mapping="/images/*" location="resources/images/"/&gt;&lt;/beans&gt; Controlle类 开启tomcat后就可以扫描找到对应的controller类，通过/con/test找到对应的方法，返回success.jsp页面。1234567891011121314151617package com.spring.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.UUID;@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test() t &#123; return "success"; &#125;&#125; 2、请求参数绑定@RequestMapping注解 这是一个非常重要的注解。这个注解用于用户的请求路径。 **作用：用于建立请求URL和处理请求方法之间的对应关系。当该注解放在类上的时候就表示的是一级访问目录。当该方法放在方法上的时候就表示是二级访问目录。属性：value：用于指定请求的URL。它和path属性的作用是一样的。method：用于指定请求的方式。 例如： 1、@RequestMapping(path = “/hello”,method = {RequestMethod.POST})params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一摸一样。2、@RequestMapping(path = “/hello”,method = {RequestMethod.POST},params = {“username”})&lt;a href=“user/hello?username=111”&gt;asdasd &lt;/ a&gt;3、@RequestMapping(path = “hello”,headers = {“Accept”})，headers：发送的请求中必须包含请求头** 请求参数绑定 请求参数的绑定说明 绑定机制 表单提交的数据都是k=v格式的，username=111&amp;&amp;password=222 SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的 要求：提交提交表单的name和参数的名称是相同的 支持的数据类型 基本数据类型和字符串类型 实体类型（JavaBean） 集合数据类型（List，map集合等）基本数据类型和字符串类型 对于普通的基本类型参数，只需要在方法的参数中参数名与前端提交的form表单的name名字一样就可以，传递到后端。12345678@Controller@RequestMapping(path = "user")public class controller &#123; @RequestMapping(path = "hello") public String sayHellow(String username,String password)&#123; return "success"; &#125;&#125; 12345&lt;form action="user/hello"&gt; &lt;input type="text" name="username"&gt; &lt;input type="text" name="password"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 直接就可以获取表单的username和password。实体类型（JavaBean） 这里面的Account是一个类，类里面包含了username、password、user（对象），有get和set方法，同时user对象有name、和age两个属性，也有get和set方法。这里面需要表单名称和对象属性名称一致。123456789@Controller@RequestMapping(path = "user")public class controller &#123; @RequestMapping(path = "hello") public String sayHellow(Account account)&#123; System.out.println(account); return "success"; &#125;&#125; 1234567&lt;form method="post" action="user/hello" &gt; &lt;input type="text" name="username"&gt; &lt;input type="text" name="password"&gt; &lt;input type="text" name="user.name"&gt; &lt;input type="text" name="user.age"&gt; &lt;input type="submit" name="submit"&gt;&lt;/form&gt; 集合数据类型（List，map集合等） 这里面的list和map集合，可以通过类似于数组索引的东西进行存储数据。list集合用的是0开始的索引（数组下标），map集合用的制定的字符串形式的索引。Account类 12345public class Account implements Serializable &#123; private String username; private String password; private List&lt;User&gt; list; private Map&lt;String,User&gt; map; controller类 123456789@Controller@RequestMapping(path = "user")public class controller &#123; @RequestMapping(path = "hello",headers = &#123;"Accept"&#125;) public String sayHellow(Account account)&#123; System.out.println(account); return "success"; &#125;&#125; 123456789&lt;form method="post" action="user/hello" &gt; &lt;input type="text" name="username"&gt; &lt;input type="text" name="password"&gt; &lt;input type="text" name="list[0].name"&gt; &lt;input type="text" name="list[0].age"&gt; &lt;input type="text" name="map['one'].name"&gt; &lt;input type="text" name="map['one'].age"&gt; &lt;input type="submit" name="submit"&gt;&lt;/form&gt; 获取原生Servlet的API 对于controller的每一个方法，实际上都是一个servlet。同样的也可以获取原生的api，像写servlet那样进行交互。 直接书写request、response就可以了。 1234567891011121314@Controller@RequestMapping(path = "user")public class controller &#123; @RequestMapping(path = "hello",headers = &#123;"Accept"&#125;) public String sayHellow(HttpServletRequest request, HttpServletResponse response)&#123; System.out.println(request); HttpSession session = request.getSession(); System.out.println(session); ServletContext context = session.getServletContext(); System.out.println(context); System.out.println(response); return "success"; &#125;&#125; 这些servlet的方法都是可以用的。 123response.setContentType("text;html;charset=utf-8");response.setContentType("application/json;charset=utf-8");response.getWriter().append(json); 3、SpringMVC 常用注解@RequestParam 作用：把请求中指定名称的参数给控制器中的形参赋值 属性：name：请求参数中的名称required：请求参数中是否必须提供此参数。默认为true，表示必须提供，如果不提供就报错。 例如：当前台传输的数据的名称与后台参数列表中的名字不一样的时候，就可以用这种方法，这里的name属性和value是一样的。这里name的属性值就是前台传输过来参数的名称。这种避免了两个名字必须一样的问题。 12345678@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test(@RequestParam(name = "username") String name) &#123; return "success"; &#125;&#125; @RequestBody 作用：用于获取请求体的内容，直接使用得到的是key=value&amp;key=value …结构的数据。get请求方式不适用。 属性：required：是否必须有请求体。默认值是true，当前取值为true时，get请求方式会报错。如果取值为false，get请求得到的是null。 例如：获取整个请求体的内容。 12345678@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test(@RequestBody String body) &#123; return "success"; &#125;&#125; @PathVariable 作用：拥有绑定URL中的占位符，例如：url中有/delete/{id}，{id}就是占位符 属性：value：指定url中的占位符名称。 Restful风格的url请求路径一样，可以根据不同的请求方式去执行后台的不同方法。 restful风格的url优点：结构清晰、符合标准、易于理解、容易扩展测试：localhost:8080/user/hello/1012345678@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test/&#123;sid&#125;") public String test(@PathVariable(name = "sid") String id) &#123; return "success"; &#125;&#125; @RequestHeader 作用：用于获取请求消息头 属性：value：提供消息头名称。required：是否必须有此消息头。 实际开发中不怎么用。获取Accept内容。12345678@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test(@RequestHeader(value = "Accept") String header) &#123; return "success"; &#125;&#125; @CookieValue 作用：用于指定cookie名称的值传入控制器的方法参数。 属性：value：cookie名称。required：是否必须有此cookie。 12345678@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test(@CookieValue(value = "") String copkie) &#123; return "success"; &#125;&#125; @ModelAttribute 作用：可以修饰方法和参数1、出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。2、出现在参数上，获取指定的数据给参数赋值。 属性：value：用于获取数据的key。key可以是pojo的属性名称，也可以是map结构的key。 应用场景：当表单提交数据不是完整的实体数据时，保证没有提交数据的字段使用数据库对象原来的数据。例如：我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段设置为null，此时就可以使用该注解。 在方法上： 12345678910111213@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String sayHellow() &#123; System.out.println("sayHello"); return "success"; &#125; @ModelAttribute public void showUser()&#123; System.out.println("showUser"); &#125;&#125; 方法有返回值，返回值会成为下一个方法的对应参数。 123456789101112131415161718@Controller@RequestMapping(path = "user")public class controller &#123; @RequestMapping(path = "hello") public String sayHellow(User user)&#123; System.out.println("sayHello.."); return "success"; &#125; @ModelAttribute public User showUser(String name)&#123; System.out.println("shouUser.."); User user = new User(): user.setName(name); user.setAge(10); user.setDate(new Date()); return user; &#125;&#125; 方法无返回值：在这里中被注解的方法先执行，这里呢形参有一个Map集合，我们最后将user对象放入到Map集合中去，之后后执行sayHello方法时在取出来。用的也是一个注解。这里就是用在参数上。 123456789101112131415161718@Controller@RequestMapping(path = "user")public class controller &#123; @RequestMapping(path = "hello") public String sayHellow(@ModelAttribute("aaa") User user)&#123; System.out.println("sayHello.."); return "success"; &#125; @ModelAttribute public void showUser(String name, Map&lt;String,User&gt; map)&#123; System.out.println("shouUser.."); User user = new User(): user.setName(name); user.setAge(10); user.setDate(new Date()); map.put("aaa",user); &#125;&#125; @SessionAttributes 作用： 用于多次执行控制器方法间的参数共享。 属性：value：用于指定存入属性的名称。type：用于指定存入数据的数据类型。 model将值放入到RequestScope中，@SessionAttributes只能修饰类。将该值放入到sessionScope中。 12345678910@Controller@RequestMapping(path = "user")@SessionAttributes(value = "msg")public class controller &#123; @RequestMapping(path = "hello") public String sayHellow(Model model)&#123; model.addAttribute("msg","1111"); return "success"; &#125;&#125; 清除 12345@RequestMapping(path = "del") public String delSessionAttribute(SessionStatus status)&#123; status.setComplete(); return "success";&#125; 4、返回值类型及响应数据类型响应返回值之String类型 controller的方法返回的字符串可以指定逻辑视图的名称，根据视图解析器为物理视图地址。123456789@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test()&#123; System.out.println("test....."); return "success"; &#125;&#125; 响应返回值之void类型 默认会去找testVoid.jsp这个文件。 12345@RequestMapping(path = "testVoid") public void testVoid()&#123; System.out.println("test....."); &#125; 可以利用请求转发，然后去跳转到success.jsp页面，重定向因为是两次请求，所以无法访问WEB-INF中的内容 1234567891011121314@RequestMapping(path = "testVoid") public void testVoid(HttpServletRequest request, HttpServletResponse response) throws Exception, IOException &#123; System.out.println("test....."); //请求转发// request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response);// 重定向// response.sendRedirect(request.getContextPath()+"/index.jsp");// 直接响应 response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=utf-8"); response.getWriter().print("hello"); return; &#125;&#125; 响应返回值之ModelAndView类型 controller方法返回字符串可以指定逻辑视图的名称，根据视图解析器为物理视图的地址。 1234567891011@RequestMapping(path = "testModel") public ModelAndView testModel()&#123; System.out.println("test....."); ModelAndView mv = new ModelAndView(); User user = new User(); //把user对象存储到mv对象中去，也会把user对象存储到request对象中 mv.addObject("user",user); //跳转到哪个页面 mv.setViewName("success"); return mv; &#125; 响应之使用forward和redirect进行页面跳转这两个方法用不了视图解析器，需要自己去写路径。 forward转发：controller方法在提供了String类型的返回值之后，默认就是请求转发。关键字forward。 123456@RequestMapping(path = "testString") public String testString()&#123; System.out.println("test....."); //return "forward:/WEB-INF/pages/success.jsp"; return "redirect:index.jsp"; &#125; @ResponseBody响应json数据我们知道当用户发送一个请求的时候，就会拦截所有的资源，导致的一个问题就是静态资源（img、css、js）也会被拦截到，从而不能被使用。解决问题就是需要配置静态资源不进行拦截，在springMVC.xml配置文件添加如下配置。 mvc:resources标签配置不过滤 获取json数据：利用RequestBody这个注解。ajax12345678910111213141516171819$(".btn")[0].onclick = function()&#123; $.ajax(&#123; type : "post", url : "con/testAjax", cache : false, data : &#123; "username":"hhhh", "password":"bbbb" &#125;, dataType : "text", success : function(msg) &#123; var user = JSON.parse(msg); alert(user.username); &#125;, error : function(XMLHttpRequest, textStatus, errorThrown) &#123; alert("获取数据失败！"); &#125; &#125;) &#125; 有三种获取的方式： 1、简单的，这样可以获取数据。12345@RequestMapping(path = "testAjax") public String testAjax(User user)&#123; System.out.println(user); return "success"; &#125; 执行结果： 2、直接为这个字符串12345@RequestMapping(path = "testAjax") public String testAjax(@RequestBody String body)&#123; System.out.println(body); return "success"; &#125; 3、导入json的相关jar包 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; 利用@ResponseBody注解，该注解可以将对象转换成字符串返回给前端的success回调函数。 12345678@RequestMapping(path = "testAjax") public @ResponseBody User testAjax(User user)&#123; System.out.println(user); System.out.println(user.getUsername()); user.setUsername("aaaa"); user.setPassword("aaaa"); return user; &#125; 5、实现文件上传传统方式 必要前提1、form表单的enctype取值必须是：multipart/form-data（默认值是：application/x-www-form-urlencoded）2、method属性必须是：post3、提供一个文件选择域input type=”file” 依赖的jar，借助第三方组件。 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; 过程分析1、首先必须要有一个前端的页面，这个待会再说，不是重点。2、上传的文件都是在request请求中的，这个上传的方法之所以要用post是因为如果用get请求的话，会把文件上传的内容全部放在请求的地址中。如果是post请求的话，会将所有的内容放入到请求体之中。3、然后我们要获取要放入文件的文件路径。判断这个路径是不是存在的，如果是不存在的，那么就创建一个文件夹。4、解析request对象，这是一个list集合，在这个集合中还含有其他的普通表单项，所以需要判断是不是文件项。5、获取文件的名称，然后输入到对应的目录下，删除临时文件。12345678910111213141516171819202122232425262728293031323334@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test(HttpServletRequest request) throws Exception &#123; //使用fileupload组件完成文件上传 //上传的位置 String realPath = request.getSession().getServletContext().getRealPath("/uploads/"); //判断，该路径是否存在 File file = new File(realPath); if(!file.exists()) file.mkdir();// 解析request对象，获取上传文件项 DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory);// 解析request List&lt;FileItem&gt; items = upload.parseRequest(request);// 遍历 for(FileItem fileItem:items)&#123; //进行判断，当前item对象是否是上传文件项。 if(!fileItem.isFormField())&#123; //不是普通表单项 //获取上传文件的名称 String filename = fileItem.getName();// 完成上传 fileItem.write(new File(realPath,filename));// 删除临时文件 fileItem.delete(); &#125; &#125; return "success"; &#125;&#125; 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2019/6/30 Time: 0:09 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;文件上传&lt;/h3&gt;&lt;form action="con/test" method="post" enctype="multipart/form-data"&gt; 选择文件：&lt;input type="file" name="upload"&gt;&lt;br&gt; &lt;input type="submit" value="上传"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 框架实现文件上传 原理这里我们自己去配置一个文件解析器，然后可以直接在controller里面获取文件上传项。这里参数中的upload必须和input上传文件标签中的upload是一样的。 主要代码，我们只需要修改上面的springMVC.xml文件就可以了，这里添加了一个bean，这里的id必须是multipartResolver 123&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;/bean&gt; controller类 123456789101112131415161718192021@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test(HttpServletRequest request, MultipartFile upload) throws Exception &#123; //使用fileupload组件完成文件上传 //上传的位置 String realPath = request.getSession().getServletContext().getRealPath("/uploads/"); //判断，该路径是否存在 File file = new File(realPath); if(!file.exists()) file.mkdir(); //获取文件的名字 String fileName = upload.getOriginalFilename(); //把文件的名字设置成唯一值 String uuid = UUID.randomUUID().toString().replace("-","");W fileName = uuid+"_"+fileName; // 完成上传 upload.transferTo(new File(realPath,fileName)); return "success"; &#125;&#125; 这里只是解析和上传的时候和之前不太一样。 6、 异常处理 编写自定义异常类（做提示信息） 编写异常处理器 配置异常处理器（跳转到提示页面）主要代码自定义异常类 12345678910111213141516package com.spring.exception;public class SysException extends Exception &#123; private String message; public SysException(String message) &#123; this.message = message; &#125; @Override public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 异常处理器，这里的ex就是接收抛出的异常，利用ModelAndView跳转页面。 123456789101112131415161718192021222324package com.spring.resolver;import com.spring.exception.SysException;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class SysResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; SysException e = null; if(ex instanceof SysException)&#123; e = (SysException) ex; &#125;else&#123; e = new SysException("系统正在维护"); &#125; ModelAndView mv = new ModelAndView(); mv.addObject("errorMsg",e.getMessage()); mv.setViewName("error"); return mv; &#125;&#125; 测试类：通过throw向上抛出异常。 12345678910111213141516171819202122232425package com.spring.controller;import com.spring.exception.SysException;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import java.util.UUID;@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test() throws Exception&#123; try &#123; int a = 10 / 0; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new SysException("出错了....."); &#125; return "success"; &#125;&#125; 配置处理器springMVC.xml配置文件 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "&gt; &lt;context:component-scan base-package="com.spring"&gt;&lt;/context:component-scan&gt;&lt;!--视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置异常处理器--&gt; &lt;bean id="sysResolver" class="com.spring.resolver.SysResolver"&gt;&lt;/bean&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; 运行结果点击后 7、拦截器原理 类似于Servlet开发中的过滤器Filter，用于对处理器（controller）进行预处理和后处理。用户可以自己定义一些拦截器来实现特定的功能。 拦截器链就是将拦截器按一定顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器和过滤器的区别 过滤器是servlet规范中的一部分，任何java web工程都可以使用。 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能用。 过滤器在url-pattern中配置了/*之后，可以对所有要访问的资源所拦截。 拦截器只会拦截访问的控制器方法，如果访问的是jsp，html，css，image或者js是不会进行拦截的。自定义拦截器的步骤第一步，编写一个普通类实现HandlerInterceptor接口 123456789101112131415package com.spring.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Interceptor implements HandlerInterceptor &#123; //预处理，controller方法执行之前，return 为true是放行执行下一个拦截器，如果没有，执行controller中的代码 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("interceptor的preHandle执行了"); return true; &#125;&#125; 第二步，配置拦截器springMVC.xml 1234567891011&lt;!-- 配置异拦截器--&gt; &lt;mvc:interceptors&gt;&lt;!-- 配置具体的拦截器--&gt; &lt;mvc:interceptor&gt;&lt;!-- 具体拦截哪一个方法--&gt; &lt;mvc:mapping path="/con/*"/&gt;&lt;!-- 配置拦截器类--&gt; &lt;bean class="com.spring.interceptor.Interceptor" /&gt;&lt;!-- 不要拦截哪个方法--&gt;&lt;!-- &lt;mvc:exclude-mapping path=""/&gt;--&gt; &lt;/mvc:interceptor&gt; 运行结果 HandlerInterceptor其余的三个方法上述将了第一个方法这里再次回顾一下 preHandle方法是controller方法执行前拦截的方法 可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有就执行controller中的方法。 return false不放行，不会执行controller中的方法。 postHandle方法是controller方法执行后执行的方法，在jsp视图执行前可以使用request或者response跳转到指定的页面如果制定了跳转页面，那么，controller方法跳转的页面将不会显示 afterCompletion方法在jsp执行后执行rerequest或者response不能跳转到指定的页面配置多个拦截器在创建一个拦截器类。然后配置，这里的执行顺序是Interceptor的preHandle –&gt; Interceptor1的preHandle –&gt; controller方法 —&gt;Interceptor1的postHandle –&gt; Interceptor的postHandle –&gt;Interceptor1的afterCompletion –&gt; Interceptor的afterCompletion123456789101112&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/con/*"/&gt; &lt;bean class="com.spring.interceptor.Interceptor" /&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/con/*"/&gt; &lt;bean class="com.spring.interceptor.Interceptor1" /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于springMVC的运行过程的理解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%AF%B9%E4%BA%8EspringMVC%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天又复习了一下springMVC的框架，又看了书上的解释，现在对springMVC运行原理做点总结，说的不好，请大佬们不要介意。 啥是springMVC？ Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不会直接处理请求。而是调用业务层的方法进行处理，而业务层调用持久层，通过Spring的依赖注入功能，这些bean被注入到控制器中。 springMVC是SSM中的s之一。springMVC中的组件 1、DispatcherServlet为前端控制器，它的作用相当于CPU，一切的工作活动都由这个前端控制器来控制。所有的请求都有经过它来统一分发。 2、HandlerMapping 为处理器映射器，为用户请求的url，能够完成客户请求到Controller映射。 。 3、HandlerAdapyer 为处理器适配器，找到对应controller。 4、ViewResolver 为视图解析器解析View对象，返回给前端的视图页面。springMVC原理图 springMVC的真正内部执行过程是这样的。web.xml DispatcherServlet是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项：（1）截获符合特定格式的URL请求。（2）初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。（3）初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。 对应web.xml文件 12345678910111213141516171819202122&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!-- 配置servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 加载SpringMVC配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 在启动tomcat的时候，服务器解析web.xml中的文件，取到前端控制器dispatcherServlet，其实前端控制器就是一个servlet，这里servlet-mapping标签配置的是我们前端控制器要拦截的的路径，这里的/表示所有的路径。init-param标签里面是需要初始化的文件，这里就初始化了springMVC.xml这个配置springMVC的文件。 一般我们还在web.xml中加入解决中文乱码的配置文件 12345678910111213&lt;!-- 解决中文乱码--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; springMVC.xml这个文件12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "&gt;&lt;!-- 扫描对应的包--&gt; &lt;context:component-scan base-package="com.spring"&gt;&lt;/context:component-scan&gt;&lt;!-- 视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;/bean&gt;&lt;!-- 映射处理器--&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping" abstract="true"/&gt;&lt;!-- 处理器适配器--&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter" abstract="true"/&gt; &lt;mvc:annotation-driven /&gt;&lt;!-- 静态资源--&gt; &lt;mvc:resources mapping="/css/*" location="resources/css/"/&gt; &lt;mvc:resources mapping="/js/*" location="resources/js/"/&gt; &lt;mvc:resources mapping="/images/*" location="resources/images/"/&gt;&lt;/beans&gt; 第一个点：扫描对应的包context:component-scan，以完成Bean创建和自动依赖注入的功能 。这里利用了spring的注入，注解注入。 第二个点：bean id=”internalResourceViewResolver” 视图解析器，用于渲染页面返回页面，第一个property指的是对应的文件夹下，第二个代表后缀。 mvc:annotation-driven 为开启springMVC框架的注解的支持-。 mvc:resources为配置静态资源，那些静态资源可以通过。在加载springMVC文件的时候这些都解析了。只要来一个请求就会直接执行。Controller 1234567891011121314151617package com.spring.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.UUID;@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test() t &#123; return "success"; &#125;&#125; 根据路径来执行每个方法。然后返回一个success.jsp，这里就经过了视图解析器，最终稿返回到前端页面（客户端）。]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>springMVC</tag>
        <tag>运行原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js原型链的世界]]></title>
    <url>%2F2019%2F08%2F02%2Fjs%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[js的继承关系不同意搞懂，原型链傻傻不明白，今天用通俗易懂的讲解和例子为大家呈现最简单的原型链理解。 原型链是什么鬼？能干啥？ 每一个类都有一个原型，而这个原型和对象实例之间又有十分微妙的关系。例如：下面的创建对象的代码。 1234function Person(name)&#123; this.name = name;&#125;var person = new Person("nan"); 实际上在函数的内部执行了这个：这里的注释部分实际上就是我们创建对象的时候，执行的函数，也是有返回值的。所以并不是用函数（类）创建对象就没有返回值。 12345678function Person(name)&#123; //var this = &#123; // __proto__:Person.prototype // &#125; this.name=name; // return this &#125; var person = new Person("nan"); 不知道大家看懂了没，注释部分是浏览器内部执行的，我们不需要写，这个是原理，而proto这个是对象的属性，跟我们平常用的是一样的，他也是和这个this.name之后的结果是平级的，都存储在this对象中。而Person.prototype就是我们所说的原型，这是一个对象，隶属于类的对象。 12345678function Person(name)&#123; //var this = &#123; // __proto__:Person.prototype， // name:"nan" // &#125; // return this &#125; var person = new Person("nan"); 而原型链就是很多个原型，形成的链式结构，先看一个代码： 12345678910111213141516Grand.prototype.lastname = "heihei";function Grand()&#123; this.say = 'en';&#125;var grand = new Grand();Father.prototype = grand;function Father()&#123; this.name = "hh" &#125;var father = new Father();Son.prototype = father;function Son()&#123; this.hobbit = "smoke" &#125;var son = new Son();console.log(son) 控制台结果结果： 这就是我们的链式结果，大家先了解，我们在下面会详细介绍这部分知识。 原型链的主要功能是体现在js对象的继承方面上的。 简单回顾下构造函数,原型和实例的关系：每一个构造函数（也就是咱们名字大写的函数function F(){}）都有一个原型对象（prototype）,原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.。 js对象有这么个有趣的规则:如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性。理解原型链 这里就以上面的代码为例：同时大家要明确，原型链脱离对象是没意义的。 如果每一个原型含有相同的属性名，那也是可以的，不过，任何方法在查找属性都是从son对象开始查找，看看有没有这个属性，如果有的话直接获取，没有再依次查找father、grand直到遍历完原型链。 至于这里为什么proto都叫Grand，是由于最上层是Grand.prototype中的contructor构造器是Grand__proto__和prototype的关系 proto属于对象属性，里面含有的是类.prototype，prototype是类属性。 例如： 1234function Person()&#123;&#125; var person = new Person(); console.log(person.__proto__ == Person.prototype); 这里是相同的，而且形成原型链的时候可以指定Person.prototype的对象。实际原型链分析1、简单类型 1234567891011Person.prototype = &#123; name : 'a', sayName : function()&#123; console.log(this.name) &#125;&#125;function Person()&#123; this.name = 'b';&#125;var person = new Person();person.sayName(); 1234567891011Person.prototype = &#123; name : 'a', sayName : function()&#123; console.log(this.name) &#125;&#125;function Person()&#123; // this.name = 'b';&#125;var person = new Person();person.sayName(); 将Person中的this.name注释掉，发现就是输出的是原型的值，这也再次验证了上面说的，对象查找属性是从原型链开始查找的，逐步向上查找。2、复杂类型12345678910111213141516171819Grand.prototype.lastname = "heihei";function Grand()&#123; this.say = 'en';&#125;var grand = new Grand();Father.prototype = grand;function Father()&#123; this.name = "hh" &#125;var father = new Father();Son.prototype = father;function Son()&#123; this.hobbit = "smoke" &#125;var son = new Son();console.log(son.hobbit);console.log(son.name);console.log(son.say);console.log(son.lastname); 这样也再再次验证了。利用实现对象的继承 实际上上述的例子就实现了上面的对象继承，但是对于这种情况：无法实现传参。 123456789101112Person.prototype.info = function()&#123; console.log("name:"+this.name+",age"+this.age+",grade:"+this.grade); &#125; function Person(name,age)&#123; this.name = name; this.age = age; &#125; Student.prototype = new Person(); function Student(name,age,grade)&#123; this.grade = grade &#125; var stu = new Student("戴",20,11); 这里的name和age都没有传入进去。我们可以输出一下。 1console.log(stu); 这里面的值都是undefined。有的人喜欢这样去修改。 123456789101112131415Person.prototype.info = function()&#123; console.log("name:"+this.name+",age"+this.age+",grade:"+this.grade); &#125; function Person(name,age)&#123; this.name = name; this.age = age; &#125; Student.prototype = new Person(); function Student(name,age,grade)&#123; this.grade = grade &#125; var stu = new Student(11); stu.name = "戴"; stu.age = 20; stu.info(); 第一眼看来，这是正确的，但是实际上这里个问题就是麻烦，不符合正常的面向对象的构造对象的步骤，繁琐。1console.log(stu) 这里实际上是再stu对象中，增加了两个实例属性。这也是不符合我们的要求的，我们想的是覆盖undefined。 最终继承代码，也是最牛叉的。 12345678910111213141516Person.prototype.info = function()&#123; console.log("name:"+this.name+",age"+this.age+",grade:"+this.grade); &#125; function Person(name,age)&#123; this.name = name; this.age = age; &#125; Student.prototype = new Person(); function Student(name,age,grade)&#123; Person.call(this,name,age); // Person.apply(this,[name,age]) this.grade = grade &#125; var stu = new Student("戴",20,11); stu.info(); console.log(stu); 利用了一个call或者apply就可以实现。最后一个例子（利于理解） 12345678910111213141516171819202122232425262728293031function Animal(age,sex)&#123; this.sex = sex; this.age = age; this.info = function()&#123; console.log("年龄:"+this.age+",性别:"+this.sex); &#125; &#125; Dog.prototype = new Animal(); function Dog(name,age,sex)&#123; this.name = name; Animal.call(this,age,sex); this.bark = function()&#123; console.log(this.name+"的叫声wangwangwang"); &#125; &#125; var dog = new Dog("hsq",2,'m'); dog.info(); dog.bark(); Cat.prototype = new Animal(); function Cat(name,age,sex)&#123; this.name = name; Animal.call(this,age,sex); this.bark = function()&#123; console.log(this.name+"的叫声miaomiaomiao"); &#125; &#125; var cat = new Cat("bsm",2,'f'); cat.info(); cat.bark();]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>原型链</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂的js闭包]]></title>
    <url>%2F2019%2F08%2F01%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84js%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包在js中是非常重要的一部分，也是可以说最难的一部分，这篇文章讲带你去理解闭包与、作用域链、执行期上下文的关系，带你去理解js中查找查找变量的底层原理。 1、闭包是什么鬼？ 当内部函数被保存到了外部时，将会生成闭包。闭包会导致原有的作用域链不释放，造成内存泄露。 如果i不知道作用域链是什么鬼，那么请看前两篇。12345678function outer()&#123; function inner()&#123; &#125; return inner;&#125;var demo = outer();demo(); 2、闭包是这么个东西 首先，在执行var demo = outer();之前（这个是一个函数调用），outer函数产生了一个执行期上下文，产生了一个作用域链。 执行后将inner函数给到了demo 1var demo = function inner()&#123; &#125; 再次执行的demo();之前，inner本身产生了一个执行期上下文，和一个新的作用域链，outer()。执行完他的作用域链就消失了。 最后执行，执行函数。3、举个栗子示例1123456789101112function add()&#123; var count = 0; function demo()&#123; count++; console.log(count); &#125; return demo;&#125;var counter = add();counter();counter();counter(); 如果不知道闭包这个概念，一定会认为是输出三个1； 我们来分析一下三个 counter()；第一个执行，这里通过count++，加加到作用域链中。输出1 然后执行 counter()，这里的 数据再次加一，之前说过，函数中所有查找变量和对数据的操作都是查找的作用域链。 同理，第三次。示例2123456789101112131415function test()&#123; var num = 100; function a()&#123; num++; console.log(num); &#125; function b()&#123; num--; console.log(num); &#125; return [a,b];&#125;var c = test();c[0]();c[1](); 这个和第一题也是同理示例3 1234567891011121314function eater()&#123; var food = ""; function a()&#123; console.log("i am eating" + food); food = ""; &#125; function b(myfood)&#123; food = myfood; &#125; return [a,b]; &#125; var eater1 = eater(); eater1[1]('banana'); eater1[0](); 这里的例子展示的是两个函数，两个作用域链，互不干扰。示例4 1234567891011121314function test()&#123; var arr = []; for(var i = 0;i &lt; 10;i++)&#123; arr[i] = function ()&#123; console.log(i + " "); &#125; &#125;; return arr; &#125; var myarr = test(); for(var j = 0;j &lt; 10;j++) &#123; myarr[j](); &#125; 如果不知道执行期上下文、作用域链、闭包的童鞋们一定会认为是输出0 - 9，但是结果： 我们来分析一下：这里面的for循环执行完之后是这样的i = 10；这里的要点在于arr[i] = function (){ }，这里输出的i是查找作用域链中的，在for循环中无法确定里面的值。作用域链： 更改代码为： 123456789101112131415function test()&#123; var arr = []; for(var i = 0;i &lt; 10;i++)&#123; (function (j)&#123; arr[j] = function ()&#123; document.write(j + " "); &#125; &#125;(i)); &#125; return arr;&#125;var myarr = test();for(var j = 0;j &lt; 10;j++)&#123; myarr[j](); &#125; 运行结果： (function(){})在test和arr[i]之间多加了一层的作用域。这样就可以正常输出了。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>作用域链</tag>
        <tag>scope</tag>
        <tag>执行期上下文</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js底层原理作用域和作用域链]]></title>
    <url>%2F2019%2F07%2F31%2Fjs%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[前几天刚刚整理的 JavaScript预编译（执行期上下文），这里需要提前明白上一篇文章，这篇文章也是为闭包铺垫理论知识。 1、作用域（[[scope]]） [[scope]]：每一个js函数都是一个对象，对象中有些属性我们可以访问，但是有些不可以，这些属性仅供js引擎存取，[[scope]]就是其中的一个。[[scope]]指的是我们所说的作用域（作用域链），其中存储了运行期期上下文的集合。每一个函数都有一个作用域。 运行期上下文：当函数执行的过程之前，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行对应执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行期上下文会被销毁。 看不懂概念不要紧，可以看下面的例子，然后看概念就会理解。 如果不知道执行期上下文的可以看：第二篇：JavaScript预编译（执行期上下文）2、作用域链 [[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。3、要知道 12345function Person()&#123;&#125;console.log(Person.name);console.log(Person.prototype); 这里的Person.name等就是可以访问的，但是Per’son.[[scope]]就是我们访问不到的。 这里每次调用都会产生一个新的AO对象。12345function test()&#123; &#125;test() -&gt; 产生一个AO&#123;&#125; 用完销毁test() -&gt; 产生一个AO&#123;&#125; 用完销毁 3、例子123456789function a()&#123; function b()&#123; var b = 234; &#125; var a = 123; b();&#125; var glob = 100; a(); a函数定义时，产生了一个[[scope]]，这里实际上只有一个GO，全局的作用域。 a在要执行之前，产生了一个执行期上下文。在这里，新创建的AO是作用域的顶端，我们在查找变量的时候就是沿着作用域链去查找变量，从顶端开始。这也就是为什么，在函数调用时，先查找自己是否含有这个属性，如果没有这个属性就去父级查找，这就是原理。这就是a函数的作用域链了。可以理解为[[scope]]为一个数组。函数本身的预编译形成AO永远是放在最顶端。 由于a函数的执行内部执行b()，所以b函数只在执行之前又产生了一个执行期上下文。所以b的作用域链直接基于a的作用域链。 b函数被创建时的作用域环境： b()执行之前进行预编译，形成的作用域链。 当b函数查找变量的时候，自顶向下查找变量。这里是为下一篇闭包铺垫理论知识。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>作用域链</tag>
        <tag>scope</tag>
        <tag>执行期上下文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS权重]]></title>
    <url>%2F2019%2F07%2F31%2FCSS%E6%9D%83%E9%87%8D%2F</url>
    <content type="text"><![CDATA[css在设置样式的时候，存在优先级的问题，比如设置了两个背景颜色，那么真正显示的究竟是哪一种颜色呢？ 一、问题提出？请问div的背景颜色为红色还是绿色呢？ 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="background-color: green;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 答案为绿色。为什么会是绿色呢？难道存在代码执行的先后的覆盖问题？请看第二个问题。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; &#125; #demo1&#123; background-color: red; &#125; .demo2&#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo2" id="demo1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; div的颜色为红色。当设置背景颜色的代码互换后div的背景颜色依然是红色。这说明并不是覆盖问题，读者可以自己试一试。 123456.demo2&#123; background-color: green;&#125;#demo1&#123; background-color: red;&#125; 二、问题的解释在css的样式中存在权重，权重最高的执行相关的代码。权值是256进制。| 相关属性 | 权值 | 相关样例 ||–|–|–|| !important | Infinity | #only{background-color: yellow!important;} ||行间样式|1000| p style = “” /p || id | 100 | #demo{} ||class、属性、伪类|10|.demo{} 、 、a:hover{}|| 标签、伪元素 | 1| div{} 、::after{} ||通配符|0|*{}|第一个问题中，由于行间样式的权值要比内联样式的权值要高，所以执行行间样式的代码。第二个问题中，由于id的权值要比class权值高，所以执行id的代码。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>css权重</tag>
        <tag>css优先级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[史上最好理解的Unicode编码讲解（Unicode的前世今生）]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%90%86%E8%A7%A3%E7%9A%84Unicode%E7%BC%96%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88Unicode%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[关于Unicode的由来，以及与utf-8、utf-16的关系、原理、计算、编码和解码。用最通俗易懂的方法讲解。 一、了解编码 在计算机中存储的数据都是01二进制的数据串，我们再电脑屏幕上看到的一切可视化的东西最终在计算机存储的都是01二进制串，现在看到我博客上的文字也是。 这里就需要一个映射关系，将我们看到的看到的字符、图片、视频转换成对应的二进制，存储到计算机中，以便于计算机能够识别。这就是我们要将的编码。 图片和视频首先会转换成字符流，然后按照编码转换成字节流，存储到计算机中。 举一个例子：在ASCLL码表中，字符’a‘对应的是97，二进制是01100001，如果我们在编辑器或者其他软件中输入字母a，按键盘a，那么输入法就会告诉操作系统，在计算机中调用97，然后就会显示a字符。 也就是说编码表在我们在计算机屏幕看到的数字和计算机底层之间架起了一个桥梁。至关重要！ 二、编码的历程1、开始 最早出现的是ASCLL码，是由美国人制定的，这种编码采用的是1个字节表示一个字符，也就是一个字符是八个二进制位，这里一共可以表示256个字符。起初，表示英文中所有的字符一共用了128位字符。事实上还剩下了一百多个字符空间。这128个字符中包含了数字、字母以及常用字符，例如：A是65，对应的二进制数为0100 0001。而且呢，这个128个字符只用了八位二进制数中的后七位，最前面的一位统一为0。 2、问题初现 但是很快就暴露出了问题，这128个字符表示英文没有任何问题，但是要是表示其他国家的语言就不够了。率先是欧洲决定利用起来前一位，这样就可以表示256个字符了，而紧接着又出现了一个问题，就是不同国家的同一个码点（八位二进制数）表示的符号可能不同，例如144 在阿拉伯人的 ASCII 码中是 گ，而在俄罗斯的 ASCII 码中是 ђ。 所以呢，最后人们在0-127号字符上面达成了一致，对于128 - 255号字符就尽情发挥了，这时候的码点还是一个字节。 3、再遇到波折 随着计算机的兴起，传入亚洲国家，亚洲国家有更多的字符需要存储，这样256个字符就放不下这些符号了，这时候人们决定用两个字节一共十六位，最多可以表示65535个字符。来存储全世界的字符。但是此时各个国家的编码还是不一样的。如ASCII、GB2312等。 4、程序员的噩梦 各种各样的编码方式成了系统开发者的噩梦，因为他们想把软件卖到国外，但是由于编码不同，一台计算机根本无法表示所有国家的编码。于是，他们提出了一个“内码表”的概念，可以切换到相应语言的一个内码表，这样才能显示相应语言的字母。在这种情况下，如果使用多语种，那么就需要频繁的在内码表内进行切换。这样依然很麻烦。 5、解决 最终，美国人决定设计一种标准方案来展示世界上所有语言中的所有字符，Unicode诞生了。Unicode 给所有的字符指定了一个数字用来表示该字符。规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。它的想法很简单，就是为每个字符规定一个用来表示该字符的数字，仅此而已。具体是怎样的对应关系，又或者说是如何进行划分的，就不是我们考虑的问题了， 三、Unicode 编码方案 Unicode 当然是一本很厚的字典，记录着世界上所有字符对应的一个数字。以汉字“汉”为例，它的 Unicode 码点是 0x6c49，对应的二进制数是 110110001001001，二进制数有 15 位，这也就说明了它至少需要 2 个字节来表示。可以想象，在 Unicode 字典中往后的字符可能就需要 3 个字节或者 4 个字节。 1、空间浪费？ 大家可以试想一下，有的字符需要两个字节、有的需要三个四个字节，那计算机如何去分辨该字节是几个字节的字符呢？大家第一个想到的可能是全部采用4个字节的编码，毕竟这个可以表示上亿个字符了。但是如果一个美国的新闻发布网站，全英文表示（前面已经说了代码单元也就是存储为一个字节就可以表示所有的英文字符），现在前面三个字节都是0，文件大小变成了之前的四倍或者三倍，这样浪费掉了大量的存储空间。 2、UTF系列编码什么鬼？ 为了较好的解决 Unicode 的编码问题， UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了。当然还有一个 UTF-32 的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，但是一般的字符两个字节就可以轻松解决了，只有一些其他小国家的特殊字符才采用UTF-32编码。 3、UTF-8编码 UTF-8 是一个非常惊艳的编码方式，漂亮的实现了对 ASCII 码的向后兼容，以保证 Unicode 可以被大众接受。 UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下： 对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。 对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。 编码规则如下： Unicode 十六进制码点范围 UTF-8 二进制 0000 0000 - 0000 007F 0xxxxxxx 0000 0080 - 0000 07FF 110xxxxx 10xxxxxx 0000 0800 - 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 - 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 4、插入一只广告 这里的除x外都是控制位，真正的表示位的只是x，第一个字节0xxxxxxx，可以容纳7个二进制位，第二个可以容纳11个二进制位，以此类推，然后计算左边的范围。 5、编码与解码 根据上面编码规则对照表，进行 UTF-8 编码和解码就简单多了。下面以汉字“汉”为利，具体说明如何进行 UTF-8 编码和解码。“汉”的 Unicode 码点是 0x6c49（110 1100 0100 1001），通过上面的对照表可以发现，0x0000 6c49 位于第三行的范围，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 11100110 10110001 10001001，转换成十六进制就是 0xE6 0xB7 0x89。 解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节。 UTF-16编码 在了解 UTF-16 编码方式之前，先了解一下另外一个概念——“平面”。 在上面的介绍中，提到了 Unicode 是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（2^16）字符，称为一个平面（plane）。目前，一共有 17 个（2^5）平面，也就是说，整个 Unicode 字符集的大小现在是 2^21。 最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 2^16-1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 U+010000 到 U+10FFFF。 基本了解了平面的概念后，再说回到 UTF-16。UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？ 这里有一个很巧妙的地方，在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。 辅助平面的字符位共有 2^20 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。 接下来，以汉字”𠮷”为例，说明 UTF-16 编码方式是如何工作的。 汉字”𠮷”的 Unicode 码点为 0x20BB7，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 0x20BB7 - 0x10000 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为0001000010 1110110111。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。U+D800 对应的二进制数为 1101100000000000，直接填充后面的 10 个二进制位即可，得到 1101100001000010，转成 16 进制数则为 0xD842。同理可得，低位为 0xDFB7。因此得出汉字”𠮷”的 UTF-16 编码为 0xD842 0xDFB7。 Unicode3.0 中给出了辅助平面字符的转换公式： 123H = Math.floor((c-0x10000) / 0x400)+0xD800L = (c - 0x10000) % 0x400 + 0xDC00 根据编码公式，可以很方便的计算出字符的 UTF-16 编码。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>unicode编码</tag>
        <tag>uft-8编码</tag>
        <tag>uft-16编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于浮点数丢失精度的原理]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%85%B3%E4%BA%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浮点数会存在精度丢失的现象，大很多金融的大项目中，都不去使用浮点数。因为这个数很危险，我们可以剖析一下原理。 1、前言首先我们必须要清楚 在计算机中所有的数值、代码、信息都是以01二进制存储的，也就是说我们输入的所有信息，最终都会表示成01二进制的形式。例如byte类型的 0000 1000表示的是整数8。然后我们要清楚 所有的整数类型转换成二进制，看如下代码： 12345//表示11的二进制数计算11 / 2 = 5 余 1 --&gt; 15 / 2 = 2 余 1 --&gt; 12 / 2 = 1 余 0 --&gt; 0 1 / 2 = 0 余 1 --&gt; 1 所有的小数转换成二进制：看如下代码： 1234567//0.1转换为二进制0.1 * 2 = 0.2 --&gt;00.2 * 2 = 0.4 --&gt;00.4 * 2 = 0.8 --&gt;00.8 * 6 = 1.6 --&gt;1//然后去掉10.6 * 2 = 1.2 --&gt;10.2 * 2 = 0.4 --&gt;0 这个是一直循环下去的，所以呢计算机无法精确表示0.1，这个数值而是无限接近近似表示。 所以11的二进制数是1011，这样开来所有的整数最后都会被1 / 2 = 0这样结束。 2、我们先来看这样的一段代码12345double dou = 234533464.456576564675d;System.out.println("234533464.456576564675的运行结果："+dou);float f = 997979759f;System.out.println("997979759的运行结果："+f);System.out.println("0.1+0.2的运行结果："+(0.2 + 0.1)); 结果是： 惊奇不惊奇，刺激不刺激？这种采用浮点数的方法，输出的结果就是错误的。前两位后面的精度丢失，最后一个表示的不准确。 同样再看另外一段代码123456float f1 = 20014999; double d1 = f1; double d2 = 20014999; System.out.println("f=" + f1); System.out.println("d=" + d1); System.out.println("d2=" + d2); 运行结果： 又是满满的疑问123double a = 0.3d;System.out.println(0.2d+0.1d);System.out.println(a); 我估计第三个直接刷新了好多人的三观，为啥直接存储就输出正确，运算就出错了呢？接下来我就围绕这几个问题对对大家一一解答。3、我们先了解一下浮点数在计算机中是如何存储的。 float（32位浮点数）在计算机中的表示形式。 浮点数存储都遵守IEEE754标准，具体的运算应该在计算机组成原理中会重点介绍，标准如下： 其中S表示该浮点数的正负，E代表阶码，M代表的是尾数。 一个十进制数可以表示为 : 例如：20.59375在计算机中存储为： 20.59375 = 10100.10011，这里的s = 0，E = 4 + 127 = 131 ，M = 01001001； 所以存储格式为0100 001 1010 0100 1100 0000 0000 0000。这里就是存储在计算机中的数据。 至于为什么要加127，这个是IEEE754标准规定的，但是在维基百科以及其他文献中也并没有直接说为什么是这样。 double（64位浮点数）在计算机中的表示形式。 同理这个和上面的是一样的。 实际上这个1.M表示的是比如1000.111这个数，小数点移动位为1.000111，在754标准下存储为000111位数，这么做相当于是能够多保存一位，所以float可以保存的尾数是24位（23），double为53位而不是（52）。4、我们首先来解决第二个问题 123float f1 = 20014999; double d1 = f; double d2 = 20014999; 刚才不是说所有的整数都不会丢失精度吗，这个这么不一样呢。这个实际上也是因为float保留的位数太小造成的。 我们来分析一下：先输出他们的二进制位数 123456789float f1 = 20014999; double d1 = f1; double d2 = 20014999;long l1 = Float.floatToIntBits(f1);long l2 = Double.doubleToLongBits(d1);long l3 = Double.doubleToLongBits(d2);System.out.println("f1=" + Long.toBinaryString(l1)); System.out.println("d1=" + Long.toBinaryString(l2)); System.out.println("d2=" + Long.toBinaryString(l3)); 这里遵循IEEE754标准，但是注意这里面没有符号位，这三种结果为什么不同，我们这就分析，首先我告诉大家d2的输出结果是正确的。其中前11位是阶码1000 0010 111= 1047，后面的0011 0001 0110 0111 1001 0111 0000 0000 0000 0000 0000 0000 0000便是尾数，所以1047 - 1023 = 24，所以这个数真正的结果就是（别忘了1.M）：1.0011 0001 0110 0111 1001 0111然后小数点向右移动24位，就是10011 0001 0110 0111 1001 0111 = 20014999； 我们再来看第一个我们对比着尾数1.00110001011001111001100就会发现这里的尾数要比1.001100010110011110010111少了一位，而且少的一位是1，所以进行舍入处理，进行进位变成了1.00110001011001111001100。这样就产生了误差。也就变成了20015000。大家要清楚这里不光是尾数的位数少了还有相应的进位处理。同时要记得这里面float只能保存24位小数，double可以保留53位。 第二个就不用说了，由于本身f是错的，所以呢，赋值给d1之后仍然是是错的。 第三个由于54尾尾数可以放得下该数值的二进制数，所以是正确的。 到此为止呢，大家要明确一个概念就是，如果保存的浮点数超过了，该类型的最大精度，那么就会产生是很大很严重的问题，而且存入计算机中就会是存储的错的。明确这一点之后也就产生了我们第三个问题（非常奇怪的问题），所以呢我们最后来说这个问题。5、解决第一个问题。 讲过第二个问题之后，第一个问题就非常好理解了，我们通过IEEE754的算法，可以得到这两个数的二进制表示形式，当用754标准去选取尾数的时候呢，就会截取掉一部分的尾数，造成精度丢失，其实原理是一样的。234533464.456576564675 = 2.34533464456576564675*e8,然后仍然是转换成754标准就失去了一些精度。具体的算法需要朋友们找相关的资料，这里不在赘述。6、最奇怪的问题第三个问题。1234567double a = 0.1d;double b = 0.2d;double c = a + b;System.out.println(a+&quot;的二进制数:&quot;+Long.toBinaryString(Double.doubleToLongBits(a)));System.out.println(b+&quot;的二进制数:&quot;+Long.toBinaryString(Double.doubleToLongBits(b)));System.out.println(c+&quot;的二进制数:&quot;+Long.toBinaryString(Double.doubleToLongBits(c)));System.out.println(0.3+&quot; 的二进制数:&quot;+Long.toBinaryString(Double.doubleToLongBits(0.3d))); 大家可以看到直接存储的0.3和计算之后出现的（数学上来说的0.3）在计算机中保存的二进制编码是不同的，原因就在于首先计算机中无法精确表示0.1和0.2，所以实际上a，b并不是真正的0.1和0.2，已经出现了误差，所以相加之后计算出来的值就是错的，也就是0.30000000000000004。那至于为什么能够出现直接存储就可以正常显示呢，是由于编译器优化的结果，在不计算的情况下，可以正常显示，但是没有任何意义，因为一旦参与计算或者比较大小，那么这个值就不代表数学意义上的0.1了。]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>浮点数精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript预编译（执行期上下文）]]></title>
    <url>%2F2019%2F07%2F28%2FJavaScript%E9%A2%84%E7%BC%96%E8%AF%91%EF%BC%88%E6%89%A7%E8%A1%8C%E6%9C%9F%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[很多人前端人员都知道变量提升这个概念，但是为什么会出现这样，很多人模棱两可。实际上在js中这叫做预编译，也叫做执行期上下文，在这里深度剖析一下它的底层原理。 预编译（又叫“执行期上下文”）一般来说，预编译与闭包、作用域链和闭包是密切相关的，好多人包括在企业开发的人都听说过一句话叫做变量提升和“函数声明整体提升”。这个就是预编译后的一个小结果，所以今天自己总结了一下。分为以下几个步骤来说。 大家先看看这段代码12console.log(a);var a = 1; 为什么变量的声明在输出的下面，却没有报错？值为什么是undefined？ 大家再看看下面这段代码1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; function test(a,b)&#123; console.log(a); var a = 'demo'; console.log(a); function a()&#123;&#125; console.log(a); var a = function ()&#123;&#125; console.log(a); console.log(b) var b = 1; &#125; test(1);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 大家看到这段代码是不是很震惊呢？形参、变量名、函数名都是“a”，那么输出的结果会是怎样呢？ 和大家想的一样吗？大家心里是不是有这么几个问题，前四个输出的都是a，为什么输出的结果不一样呢？而且b变量不是把1赋值给它了吗，为什么会是undefined？接下来咱们来讲讲什么是预编译（执行期上下文）。到最后大家就明白了。 预编译（‘执行期上下文’）预编译发生在函数执行之前。划重点了啊！！！！！ 这句话很重要，函数执行之前也就是在这段程序开始之前，浏览器对马上要执行的函数进行预编译！！预编译四部曲 创建AO对象 找形参和变量声明，将变量和形参作为AO属性名，值为undefined 将实参和形参相统一 在函数体里找到函数声明，值赋予函数体最后程序输出变量值的时候，就是从AO对象中拿。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>变量提升</tag>
        <tag>预编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>tags1</tag>
        <tag>tags2</tag>
      </tags>
  </entry>
</search>
