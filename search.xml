<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring框架基础]]></title>
    <url>%2F2019%2F08%2F04%2Fspring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[复习了一下spring的知识点，篇幅可能有一些长。里面有关于IOC控制反转、DI注入、和AOP面向切面编程。 1、IOC和DI配置bean 直接用在配置文件中用bean标签 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;!-- 把创建的对象交给Spring 这种方法用于默认构造函数 --&gt; &lt;bean id="accountDao" class="com.spring.dao.Impl.IAccountDaoImpl"&gt;&lt;/bean&gt; &lt;bean id="accountService" class="com.spring.service.Impl.IAccountServiceImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 通过类路径，读取配置文件创建对象。 12345678910public class Client &#123; public static void main(String[] args) &#123; //获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //根据id获取bean对象// IAccountServiceImpl accountService = (IAccountServiceImpl) ac.getBean("accountService"); IAccountService accountService = ac.getBean("accountService",IAccountService.class); accountService.saveAccount(new Account()); &#125;&#125; bean对象的作用范围 bean对象的作用范围默认情况下，bean是单例的，但是如果我们想把它改成多例的，怎么办？bean标签的scope属性：作用：用于指定bean的作用范围取值：singleton：单例的（默认值）prototype：多例的request：作用于web应用的请求范围。session：作用于web应用的会话范围。global-session：作用于集群环境的会话范围（全局会话范围），当不是集群时，他就是session1&lt;bean id="accountDao" class="com.spring.dao.Impl.IAccountDaoImpl" scope=""&gt;&lt;/bean&gt; DI 依赖注入 当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明。依赖中的维护称为DI。这里就像Person类中的name和age，一样。对于进入IOC之后的对象，需要进行初始化，用的就是DI。能注入的数据：基本类型和String、其他的bean类型（在配置文件中或者注解配置过的bean）、复杂类型/集合类型经常变化的数据不适合注入。注入的方式和：使用构造函数提供、使用set方法提供、使用注解提供使用构造函数标签使用：constructor-arg标签出现的位置：bean标签内部标签中的属性 type：用于指定 要注入数据的数据类型，该数据类型也是构造函数中某个或者某些参数类型 index：用于指定要注入数据构造函数中指定索引位置的参数赋值。索引位置从0开始 name： 用于指定构造函数中指定指定名称参数赋值 value：用于指定基本类型数据 ref：用于指定其他bean类的数据优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。IAccountServiceImpl类 1234567891011121314151617181920212223package com.spring.service.Impl;import com.spring.dao.Impl.IAccountDaoImpl;import com.spring.domain.Account;import com.spring.service.IAccountService;import java.util.Date;public class IAccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public IAccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void saveAccount(Account account) &#123; System.out.println("service保存" +name+ "," +age+"," + birthday); &#125;&#125; bean.xml 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;!-- spring中的依赖注入 --&gt;&lt;!-- 构造函数注入--&gt; &lt;bean id="accountService" class="com.spring.service.Impl.IAccountServiceImpl" &gt; &lt;constructor-arg name="name" value="test"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="age" value="12" &gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt;&lt;/beans&gt; 使用set方法注入（常用）标签使用：property标签出现的位置：bean标签内部标签中的属性 name： 用于指定注入时所调用的set方法名称 value：用于指定基本类型数据 ref：用于指定其他bean类的数据优势：在创建对象时没有明确的限制，可以直接使用默认构造函数弊端：如果有某个成员变量必须有值，则获取对象有可能set方法没有执行1234567891011121314151617181920212223242526272829package com.spring.service.Impl;import com.spring.dao.Impl.IAccountDaoImpl;import com.spring.domain.Account;import com.spring.service.IAccountService;import java.util.Date;public class IAccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public void saveAccount(Account account) &#123; System.out.println("service保存" +name+ "," +age+"," + birthday); &#125;&#125; bean.xml 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;!-- spring中的依赖注入 --&gt;&lt;!-- 构造函数注入--&gt; &lt;bean id="accountService" class="com.spring.service.Impl.IAccountServiceImpl" &gt; &lt;property name="name" value="test"&gt;&lt;/property&gt; &lt;property name="age" value="12" &gt;&lt;/property&gt; &lt;property name="birthday" ref="nono"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="nono" class="java.util.Date"&gt;&lt;/bean&gt;&lt;/beans&gt; 复杂类型的注入/集合类型的注入bean.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;!-- spring中的依赖注入 --&gt;&lt;!-- 构造函数注入--&gt; &lt;bean id="accountService" class="com.spring.service.Impl.IAccountServiceImpl" &gt; &lt;property name="array" &gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="array" &gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="map" &gt; &lt;map&gt; &lt;entry key="key1" value="value1"&gt;&lt;/entry&gt; &lt;entry key="key2"&gt; &lt;value&gt;value2&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="propertyies"&gt; &lt;props&gt; &lt;prop key="key1"&gt;value1&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2、基于注解的IOC和DI分类： 用于创建对象他们的作用就和在xml配置文件中编写一个&lt;bean&gt;标签的实现功能是一样的。 用于注入数据他们的作用就和在xml配置文件中的&lt;bean&gt;标签中写一个&lt;property&gt;标签的作用是一样的。 用于改变作用范围他们的作用集合在bean标签中使用scope属性实现的功能是一样的。 和生命周期有关他们的作用就和在bean标签中使用init-method和destory-method是一样的IOC注解 @Component：作用：用于把当前的类对象存入Spring容器中。属性：value用于指定bean的id。当我们不写的时候，它的默认值是当前的类名，且首字母小写。bean.xml文件 这里需要用到context这个名称空间 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 告知spring在创建容器的时候要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为context名称空间和约束中。--&gt; &lt;context:component-scan base-package="com.spring"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 类 这里采用用accountService作为id 12345678@Component(value = "accountService")public class IAccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void saveAccount() &#123; System.out.println("保存"); &#125;&#125; 测试类 当扫描xml文件的时候就自动给创建了类对象 12345678910public class Client &#123; public static void main(String[] args) &#123; //获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //根据id获取bean对象// IAccountServiceImpl accountService = (IAccountServiceImpl) ac.getBean("accountService"); IAccountService accountService = ac. getBean("accountService",IAccountService.class); accountService.saveAccount(); &#125;&#125; @Controller：一般用于表现层 @Service：一般用在业务层 @Repository：一般用在持久层 以上三个注解他们的作用和属性与@Component是一摸一样。 他们三个是spring框架为我们提供明确的三层使用的注解，使我们对三层对象更加清晰的。DI注解 Autowired：作用：自动按类型注入，只要容器有唯一的bean对象类型和要注入的变量类型匹配，就可以成功注入。如果ioc容器中没有任何bean类型和要注入的变量类型匹配，则报错。如果ioc容器中有多个类型匹配时，那么它首先找到对应接口的实现类，然后根据变量名=IOC容器中的id去寻找答案出现的位置：可以是变量上，也可以是方法上。细节：在使用注解注入时，set方法就不是必须的了 123456789@Service("accountService")public class IAccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 如果ioc容器中有多个类型匹配时，且对应的变量名也不匹配对应容器中的值时，@Autowire解决不了 @Qualifier作用：在按照类中注入的基础上再按照名称注入。它给类成员注入时，不能单独使用，再给方法参数注入时可以。属性：value用于指定注入bean的id 123456789@Service("accountService")public class IAccountServiceImpl implements IAccountService &#123; @Autowired @Qualifier("accountDao") private IAccountDao accountDao; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; Resource作用：直接按照在bean标签中使用的id注入。他可以独立使用属性：name：用于指定bean的id 12345678@Service("accountService")public class IAccountServiceImpl implements IAccountService &#123; @Resource(name="accountDao") private IAccountDao accountDao; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 以上三个注解只能注入其他bean类型的数据，而基本类型的String类型无法使用上述注解实现。另外集合类型的注入只能通过XML来实现。 Value：用于注入基本类型和String类型的数据属性：value用于指定数据的值。他可以使用spring中的SpEl(Spring的EL表达式)SpEl的写法：${表达式} 12345678@Repository("accountDao")public class IAccountDaoImpl implements IAccountDao &#123; @Value(value="1") private int id; public void saveAccount() &#123; System.out.println("保存" + id); &#125;&#125; 用于改变作用范围他们的作用就和在bean标签中使用scope属性实现的功能是一样的 Scope作用：用于指定bean的作用范围属性：value 指定范围的值。常取值：singleton、prototype默认是singleton123456789@Service("accountService")@Scope("prototype")public class IAccountServiceImpl implements IAccountService &#123; @Resource(name="accountDao") private IAccountDao accountDao; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 3、AOP面向切面编程（基于配置文件） 作用：在程序运行期间，不修改源码的基础上，对已有的方法增强 优势：减少重复代码、提高开发效率、维护方便 我们想的是在每个方法前都打印日字基本代码（1）IAccountService接口 1234567package com.spring.service;public interface IAccountService &#123; void saveAccount(); void updateAccount(int i); int deleteAccount();&#125; （2）AccountService类 123456789101112public class AccountService implements IAccountService &#123; public void saveAccount() &#123; System.out.println("执行保存"); &#125; public void updateAccount(int i) &#123; System.out.println("执行更新"); &#125; public int deleteAccount() &#123; System.out.println("执行删除"); return 0; &#125;&#125; （3）Logger类 12345678public class Logger &#123; /** * 用于打印日志，计划让其在切入点方法执行之前执行（切入点方法就是业务层方法） */ public void printLog()&#123; System.out.println("记录日志"); &#125;&#125; （4）main类 1234567public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService accountService = (IAccountService) ac.getBean("accountService"); accountService.saveAccount(); &#125;&#125; 配置bean.xml文件 1.把通知beans也交给spring来管理 使用aop:config标签表明aop的配置 使用aop:aspect标签配置切面，id：是给切面提供一个唯一标识，ref：是给定通知类的bean的id 在aop:apect标签内使用对应的标签配置通知的类型 aop:before前置通知，pointcut:用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强 切入点表达式：execution(表达式)，表达式：访问修饰符 返回值 包名.包名.类名.方法名（参数列表）123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="accountService" class="com.spring.service.Impl.AccountService"&gt;&lt;/bean&gt; &lt;bean id="logger" class="com.spring.utils.Logger"&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;!-- 配置切面--&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt; &lt;!-- 配置通知的类型，并且建立通知方法和切入点的方法名关联--&gt; &lt;aop:before method="printLog" pointcut="execution(public void com.spring.service.Impl.AccountService.saveAccount())"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 切入点表达式的写法： 标准写法：public void com.spring.service.impl.AccountServiceImpl.saveAccount()全通配写法 ：* * 。。。\ (。。) 这里的。为一个点访问修饰符可以省略：void com.spring.service.impl.AccountServiceImpl.saveAccount()返回值使用通配符：* com.spring.service.impl.AccountServiceImpl.saveAccount()包名可以使用通配符：* *.*.*.*.AccountServiceImpl.saveAccount()包名可以使用。。表示当前包及其子包：* *。。AccountServiceImpl.saveAccount()类名和方法名：* *。。*.*()参数列表：可以直接写数据类型：基本数据类型直接写名称 int，引用类型写包名.类名的方式，java.lang.String。可以使用通配符表示任意类型的数据，但是必须有参数：* *。。*.*(*)可以使用。。表示有无参数均可，有参数可以是任意类型。 实际开发中的写法： 切到业务层实现类下的所有方法： * com.spring.service.impl.*.*(。。)；四种常用通知类型Logger类这里只需要修改两个文件。 12345678910111213141516171819202122232425262728293031package com.spring.utils;public class Logger &#123; /** * 用于打印日志，计划让其在切入点方法执行之前执行（切入点方法就是业务层方法） */ /** * 前置通知 */ public void beforePrintLog()&#123; System.out.println("前置通知before记录日志"); &#125; /** * 后置通知 */ public void afterReturnPrintLog()&#123; System.out.println("后置通知afterReturn记录日志"); &#125; /** * 异常通知 */ public void afterThrowPrintLog()&#123; System.out.println("异常通知before记录日志"); &#125; /** * 最终通知 */ public void afterPrintLog()&#123; System.out.println("最终通知after记录日志"); &#125;&#125; bean.xml 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="accountService" class="com.spring.service.Impl.AccountService"&gt;&lt;/bean&gt; &lt;bean id="logger" class="com.spring.utils.Logger"&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;!-- 配置切面--&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt;&lt;!-- 前置通知--&gt; &lt;aop:before method="beforePrintLog" pointcut="execution(* com.spring.service.*.*(..))"&gt;&lt;/aop:before&gt;&lt;!-- 后置通知--&gt; &lt;aop:after-returning method="afterReturnPrintLog" pointcut="execution(* com.spring.service.*.*(..))"&gt;&lt;/aop:after-returning&gt;&lt;!-- 异常通知--&gt; &lt;aop:after-throwing method="afterThrowPrintLog" pointcut="execution(* com.spring.service.*.*(..))"&gt;&lt;/aop:after-throwing&gt;&lt;!-- 最终通知--&gt; &lt;aop:after method="afterPrintLog" pointcut="execution(* com.spring.service.*.*(..))"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 执行：异常通知只有在方法异常的情况下才会被执行，他和最终通知只能执行一个。 我们还可以用切入点表达式标签，id属性用于指点表达式唯一标识。expression属性用于指定表达式的内容。 此时该标签写在aop:aspect标签内部只能当前切面使用，它还可以写在aop:aspect外面，此时就变成了所有切面可用。这样就得放在所有aop:aspect标签之前。 123456789101112131415 &lt;aop:config&gt; &lt;!-- 配置切面--&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt;&lt;!-- 前置通知--&gt; &lt;aop:before method="beforePrintLog" pointcut-ref="pt"&gt;&lt;/aop:before&gt;&lt;!-- 后置通知--&gt; &lt;aop:after-returning method="afterReturnPrintLog" pointcut-ref="pt"&gt;&lt;/aop:after-returning&gt;&lt;!-- 异常通知--&gt; &lt;aop:after-throwing method="afterThrowPrintLog" pointcut-ref="pt"&gt;&lt;/aop:after-throwing&gt;&lt;!-- 最终通知--&gt; &lt;aop:after method="afterPrintLog" pointcut-ref="pt"&gt;&lt;/aop:after&gt; &lt;aop:pointcut id="pt" expression="execution(* com.spring.service.*.*(..))"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 环绕通知增加xml语句 12345678 &lt;aop:config&gt; &lt;!-- 配置切面--&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt; &lt;aop:around method="arroundLog" pointcut-ref="pt"&gt;&lt;/aop:around&gt; &lt;aop:pointcut id="pt" expression="execution(* com.spring.service.*.*(..))"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 增加logger类语句 123public void arroundLog()&#123; System.out.println("环绕通知"); &#125; 执行：这里没有打印saveAccount方法里面的打印输出 问题：当我们配置了环绕通知后，切入点方法没有执行，而通知方法执行了。 分析：需要有明确的切入点方法的调用。 解决：Spring框架为我们提供了一个接口，ProceedingJoinPoint。该接口y有一个方法，proceed()。此方法相当于明确调用切入点方法。该接口可以作为环绕通知方法的参数，在程序执行时，Spring框架会为我们提供该接口的实现类供我们使用。 配置在rtValue = pjp.proceed(args);之前的方法就是前置通知，在之后就时后置通知，在catch里面就是异常通知，在finally就是最终通知。它是Spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方法。123456789101112131415161718192021222324252627package com.spring.utils;import javafx.beans.binding.ObjectExpression;import org.aspectj.lang.ProceedingJoinPoint;/** * 提供公共方法 */public class Logger &#123; public Object arroundLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try &#123; Object[] args = pjp.getArgs(); System.out.println("前置通知"); rtValue = pjp.proceed(args); System.out.println("后置通知"); return rtValue; &#125; catch (Throwable throwable) &#123; System.out.println("异常通知"); throwable.printStackTrace(); &#125;finally &#123; System.out.println("最终通知"); &#125; System.out.println("环绕通知"); return null; &#125;&#125; 4、基于注解的AOP 在配置文件钟加入扫描注解和扫描AOP的配置。12&lt;context:component-scan base-package="com.spring" &gt;&lt;/context:component-scan&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 配置AOP信息对实现类添加注解，保证扫描包的时候该对象进入IOC容器 12@Service("accountService")public class AccountService implements IAccountService &#123; 12@Component("logger")public class Logger &#123; logger类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.spring.utils;import javafx.beans.binding.ObjectExpression;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * 提供公共方法 */@Component("logger")@Aspect//表示当前类是一个切面类public class Logger &#123; @Pointcut("execution(* com.spring.service.*.*(..))") private void pt()&#123;&#125; /** * 前置通知 */ @Before("pt()") public void beforePrintLog()&#123; System.out.println("前置通知before记录日志"); &#125; /** * 后置通知 */ @AfterReturning("pt()") public void afterReturnPrintLog()&#123; System.out.println("后置通知afterReturn记录日志"); &#125; /** * 异常通知 */ @AfterThrowing("pt()") public void afterThrowPrintLog()&#123; System.out.println("异常通知before记录日志"); &#125; /** * 最终通知 */ @After("pt()") public void afterPrintLog()&#123; System.out.println("最终通知after记录日志"); &#125; /** * 环绕通知 */ //@Around("pt()") public void arroundLog(ProceedingJoinPoint pjp)&#123; System.out.println("环绕通知"); &#125;&#125; 执行：直接使用这四个注解的方式它的调用顺序是有问题的。 使用环绕通知：执行四种通知 123456789101112131415161718@Around("pt()") public Object arroundLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try &#123; Object[] args = pjp.getArgs(); System.out.println("前置通知"); rtValue = pjp.proceed(args); System.out.println("后置通知"); return rtValue; &#125; catch (Throwable throwable) &#123; System.out.println("异常通知"); throwable.printStackTrace(); &#125;finally &#123; System.out.println("最终通知"); &#125; System.out.println("环绕通知"); return null; &#125; 执行：这样的顺序就没问题了 对于注解开发，更建议大家使用环绕通知，而不是四种注解的方式。同时我们也可以修改为全注解的方式。用注解的配置类代替bean.xml文件。bean.xml文件的信息如下： 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;context:component-scan base-package="com.spring" &gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 新建一个SpringConfiguration类 12345@Configuration@ComponentScan(basePackages = "com.spring")@EnableAspectJAutoProxypublic class SpringConfiguration &#123;&#125; 修改test类 class Test &#123;123456 public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); IAccountService accountService = (IAccountService) ac.getBean(&quot;accountService&quot;); accountService.saveAccount(); &#125;&#125; 执行： 5、jdbcTemplate的使用请看https://blog.csdn.net/weixin_44588495/article/details/93852840]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMVC基础知识]]></title>
    <url>%2F2019%2F08%2F03%2FspringMVC%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[复习了一下springMVC的知识点，随便总结了一下，几乎涵盖了所有springMVC的基础知识。篇幅可能有一些长。 1、简单搭建一个springMVC项目目录 引入所需要的依赖 这里我们采用maven工程去管理我们所需要的jar包。在pom.xml中引入我们的依赖。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;!-- 锁定版本号--&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置web.xml 这里面配有前端控制器和加载springMVC的配置文件。同时我们一般配置解决中文乱码。12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!-- 配置servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 加载SpringMVC配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; springMVC.xml文件 这里需要配置扫描对应的controller注解、配置视图解析器、配置映射处理器、配置处理器适配器、开启注解扫描、过滤静态资源等。12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "&gt;&lt;!-- 扫描对应的包--&gt; &lt;context:component-scan base-package="com.spring"&gt;&lt;/context:component-scan&gt;&lt;!-- 视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;/bean&gt;&lt;!-- 映射处理器--&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping" abstract="true"/&gt;&lt;!-- 处理器适配器--&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter" abstract="true"/&gt; &lt;mvc:annotation-driven /&gt;&lt;!-- 静态资源--&gt; &lt;mvc:resources mapping="/css/*" location="resources/css/"/&gt; &lt;mvc:resources mapping="/js/*" location="resources/js/"/&gt; &lt;mvc:resources mapping="/images/*" location="resources/images/"/&gt;&lt;/beans&gt; Controlle类 开启tomcat后就可以扫描找到对应的controller类，通过/con/test找到对应的方法，返回success.jsp页面。1234567891011121314151617package com.spring.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.UUID;@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test() t &#123; return "success"; &#125;&#125; 2、请求参数绑定@RequestMapping注解 这是一个非常重要的注解。这个注解用于用户的请求路径。 **作用：用于建立请求URL和处理请求方法之间的对应关系。当该注解放在类上的时候就表示的是一级访问目录。当该方法放在方法上的时候就表示是二级访问目录。属性：value：用于指定请求的URL。它和path属性的作用是一样的。method：用于指定请求的方式。 例如： 1、@RequestMapping(path = “/hello”,method = {RequestMethod.POST})params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一摸一样。2、@RequestMapping(path = “/hello”,method = {RequestMethod.POST},params = {“username”})&lt;a href=“user/hello?username=111”&gt;asdasd &lt;/ a&gt;3、@RequestMapping(path = “hello”,headers = {“Accept”})，headers：发送的请求中必须包含请求头** 请求参数绑定 请求参数的绑定说明 绑定机制 表单提交的数据都是k=v格式的，username=111&amp;&amp;password=222 SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的 要求：提交提交表单的name和参数的名称是相同的 支持的数据类型 基本数据类型和字符串类型 实体类型（JavaBean） 集合数据类型（List，map集合等）基本数据类型和字符串类型 对于普通的基本类型参数，只需要在方法的参数中参数名与前端提交的form表单的name名字一样就可以，传递到后端。12345678@Controller@RequestMapping(path = "user")public class controller &#123; @RequestMapping(path = "hello") public String sayHellow(String username,String password)&#123; return "success"; &#125;&#125; 12345&lt;form action="user/hello"&gt; &lt;input type="text" name="username"&gt; &lt;input type="text" name="password"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 直接就可以获取表单的username和password。实体类型（JavaBean） 这里面的Account是一个类，类里面包含了username、password、user（对象），有get和set方法，同时user对象有name、和age两个属性，也有get和set方法。这里面需要表单名称和对象属性名称一致。123456789@Controller@RequestMapping(path = "user")public class controller &#123; @RequestMapping(path = "hello") public String sayHellow(Account account)&#123; System.out.println(account); return "success"; &#125;&#125; 1234567&lt;form method="post" action="user/hello" &gt; &lt;input type="text" name="username"&gt; &lt;input type="text" name="password"&gt; &lt;input type="text" name="user.name"&gt; &lt;input type="text" name="user.age"&gt; &lt;input type="submit" name="submit"&gt;&lt;/form&gt; 集合数据类型（List，map集合等） 这里面的list和map集合，可以通过类似于数组索引的东西进行存储数据。list集合用的是0开始的索引（数组下标），map集合用的制定的字符串形式的索引。Account类 12345public class Account implements Serializable &#123; private String username; private String password; private List&lt;User&gt; list; private Map&lt;String,User&gt; map; controller类 123456789@Controller@RequestMapping(path = "user")public class controller &#123; @RequestMapping(path = "hello",headers = &#123;"Accept"&#125;) public String sayHellow(Account account)&#123; System.out.println(account); return "success"; &#125;&#125; 123456789&lt;form method="post" action="user/hello" &gt; &lt;input type="text" name="username"&gt; &lt;input type="text" name="password"&gt; &lt;input type="text" name="list[0].name"&gt; &lt;input type="text" name="list[0].age"&gt; &lt;input type="text" name="map['one'].name"&gt; &lt;input type="text" name="map['one'].age"&gt; &lt;input type="submit" name="submit"&gt;&lt;/form&gt; 获取原生Servlet的API 对于controller的每一个方法，实际上都是一个servlet。同样的也可以获取原生的api，像写servlet那样进行交互。 直接书写request、response就可以了。 1234567891011121314@Controller@RequestMapping(path = "user")public class controller &#123; @RequestMapping(path = "hello",headers = &#123;"Accept"&#125;) public String sayHellow(HttpServletRequest request, HttpServletResponse response)&#123; System.out.println(request); HttpSession session = request.getSession(); System.out.println(session); ServletContext context = session.getServletContext(); System.out.println(context); System.out.println(response); return "success"; &#125;&#125; 这些servlet的方法都是可以用的。 123response.setContentType("text;html;charset=utf-8");response.setContentType("application/json;charset=utf-8");response.getWriter().append(json); 3、SpringMVC 常用注解@RequestParam 作用：把请求中指定名称的参数给控制器中的形参赋值 属性：name：请求参数中的名称required：请求参数中是否必须提供此参数。默认为true，表示必须提供，如果不提供就报错。 例如：当前台传输的数据的名称与后台参数列表中的名字不一样的时候，就可以用这种方法，这里的name属性和value是一样的。这里name的属性值就是前台传输过来参数的名称。这种避免了两个名字必须一样的问题。 12345678@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test(@RequestParam(name = "username") String name) &#123; return "success"; &#125;&#125; @RequestBody 作用：用于获取请求体的内容，直接使用得到的是key=value&amp;key=value …结构的数据。get请求方式不适用。 属性：required：是否必须有请求体。默认值是true，当前取值为true时，get请求方式会报错。如果取值为false，get请求得到的是null。 例如：获取整个请求体的内容。 12345678@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test(@RequestBody String body) &#123; return "success"; &#125;&#125; @PathVariable 作用：拥有绑定URL中的占位符，例如：url中有/delete/{id}，{id}就是占位符 属性：value：指定url中的占位符名称。 Restful风格的url请求路径一样，可以根据不同的请求方式去执行后台的不同方法。 restful风格的url优点：结构清晰、符合标准、易于理解、容易扩展测试：localhost:8080/user/hello/1012345678@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test/&#123;sid&#125;") public String test(@PathVariable(name = "sid") String id) &#123; return "success"; &#125;&#125; @RequestHeader 作用：用于获取请求消息头 属性：value：提供消息头名称。required：是否必须有此消息头。 实际开发中不怎么用。获取Accept内容。12345678@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test(@RequestHeader(value = "Accept") String header) &#123; return "success"; &#125;&#125; @CookieValue 作用：用于指定cookie名称的值传入控制器的方法参数。 属性：value：cookie名称。required：是否必须有此cookie。 12345678@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test(@CookieValue(value = "") String copkie) &#123; return "success"; &#125;&#125; @ModelAttribute 作用：可以修饰方法和参数1、出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。2、出现在参数上，获取指定的数据给参数赋值。 属性：value：用于获取数据的key。key可以是pojo的属性名称，也可以是map结构的key。 应用场景：当表单提交数据不是完整的实体数据时，保证没有提交数据的字段使用数据库对象原来的数据。例如：我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段设置为null，此时就可以使用该注解。 在方法上： 12345678910111213@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String sayHellow() &#123; System.out.println("sayHello"); return "success"; &#125; @ModelAttribute public void showUser()&#123; System.out.println("showUser"); &#125;&#125; 方法有返回值，返回值会成为下一个方法的对应参数。 123456789101112131415161718@Controller@RequestMapping(path = "user")public class controller &#123; @RequestMapping(path = "hello") public String sayHellow(User user)&#123; System.out.println("sayHello.."); return "success"; &#125; @ModelAttribute public User showUser(String name)&#123; System.out.println("shouUser.."); User user = new User(): user.setName(name); user.setAge(10); user.setDate(new Date()); return user; &#125;&#125; 方法无返回值：在这里中被注解的方法先执行，这里呢形参有一个Map集合，我们最后将user对象放入到Map集合中去，之后后执行sayHello方法时在取出来。用的也是一个注解。这里就是用在参数上。 123456789101112131415161718@Controller@RequestMapping(path = "user")public class controller &#123; @RequestMapping(path = "hello") public String sayHellow(@ModelAttribute("aaa") User user)&#123; System.out.println("sayHello.."); return "success"; &#125; @ModelAttribute public void showUser(String name, Map&lt;String,User&gt; map)&#123; System.out.println("shouUser.."); User user = new User(): user.setName(name); user.setAge(10); user.setDate(new Date()); map.put("aaa",user); &#125;&#125; @SessionAttributes 作用： 用于多次执行控制器方法间的参数共享。 属性：value：用于指定存入属性的名称。type：用于指定存入数据的数据类型。 model将值放入到RequestScope中，@SessionAttributes只能修饰类。将该值放入到sessionScope中。 12345678910@Controller@RequestMapping(path = "user")@SessionAttributes(value = "msg")public class controller &#123; @RequestMapping(path = "hello") public String sayHellow(Model model)&#123; model.addAttribute("msg","1111"); return "success"; &#125;&#125; 清除 12345@RequestMapping(path = "del") public String delSessionAttribute(SessionStatus status)&#123; status.setComplete(); return "success";&#125; 4、返回值类型及响应数据类型响应返回值之String类型 controller的方法返回的字符串可以指定逻辑视图的名称，根据视图解析器为物理视图地址。123456789@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test()&#123; System.out.println("test....."); return "success"; &#125;&#125; 响应返回值之void类型 默认会去找testVoid.jsp这个文件。 12345@RequestMapping(path = "testVoid") public void testVoid()&#123; System.out.println("test....."); &#125; 可以利用请求转发，然后去跳转到success.jsp页面，重定向因为是两次请求，所以无法访问WEB-INF中的内容 1234567891011121314@RequestMapping(path = "testVoid") public void testVoid(HttpServletRequest request, HttpServletResponse response) throws Exception, IOException &#123; System.out.println("test....."); //请求转发// request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response);// 重定向// response.sendRedirect(request.getContextPath()+"/index.jsp");// 直接响应 response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=utf-8"); response.getWriter().print("hello"); return; &#125;&#125; 响应返回值之ModelAndView类型 controller方法返回字符串可以指定逻辑视图的名称，根据视图解析器为物理视图的地址。 1234567891011@RequestMapping(path = "testModel") public ModelAndView testModel()&#123; System.out.println("test....."); ModelAndView mv = new ModelAndView(); User user = new User(); //把user对象存储到mv对象中去，也会把user对象存储到request对象中 mv.addObject("user",user); //跳转到哪个页面 mv.setViewName("success"); return mv; &#125; 响应之使用forward和redirect进行页面跳转这两个方法用不了视图解析器，需要自己去写路径。 forward转发：controller方法在提供了String类型的返回值之后，默认就是请求转发。关键字forward。 123456@RequestMapping(path = "testString") public String testString()&#123; System.out.println("test....."); //return "forward:/WEB-INF/pages/success.jsp"; return "redirect:index.jsp"; &#125; @ResponseBody响应json数据我们知道当用户发送一个请求的时候，就会拦截所有的资源，导致的一个问题就是静态资源（img、css、js）也会被拦截到，从而不能被使用。解决问题就是需要配置静态资源不进行拦截，在springMVC.xml配置文件添加如下配置。 mvc:resources标签配置不过滤 获取json数据：利用RequestBody这个注解。ajax12345678910111213141516171819$(".btn")[0].onclick = function()&#123; $.ajax(&#123; type : "post", url : "con/testAjax", cache : false, data : &#123; "username":"hhhh", "password":"bbbb" &#125;, dataType : "text", success : function(msg) &#123; var user = JSON.parse(msg); alert(user.username); &#125;, error : function(XMLHttpRequest, textStatus, errorThrown) &#123; alert("获取数据失败！"); &#125; &#125;) &#125; 有三种获取的方式： 1、简单的，这样可以获取数据。12345@RequestMapping(path = "testAjax") public String testAjax(User user)&#123; System.out.println(user); return "success"; &#125; 执行结果： 2、直接为这个字符串12345@RequestMapping(path = "testAjax") public String testAjax(@RequestBody String body)&#123; System.out.println(body); return "success"; &#125; 3、导入json的相关jar包 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; 利用@ResponseBody注解，该注解可以将对象转换成字符串返回给前端的success回调函数。 12345678@RequestMapping(path = "testAjax") public @ResponseBody User testAjax(User user)&#123; System.out.println(user); System.out.println(user.getUsername()); user.setUsername("aaaa"); user.setPassword("aaaa"); return user; &#125; 5、实现文件上传传统方式 必要前提1、form表单的enctype取值必须是：multipart/form-data（默认值是：application/x-www-form-urlencoded）2、method属性必须是：post3、提供一个文件选择域input type=”file” 依赖的jar，借助第三方组件。 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; 过程分析1、首先必须要有一个前端的页面，这个待会再说，不是重点。2、上传的文件都是在request请求中的，这个上传的方法之所以要用post是因为如果用get请求的话，会把文件上传的内容全部放在请求的地址中。如果是post请求的话，会将所有的内容放入到请求体之中。3、然后我们要获取要放入文件的文件路径。判断这个路径是不是存在的，如果是不存在的，那么就创建一个文件夹。4、解析request对象，这是一个list集合，在这个集合中还含有其他的普通表单项，所以需要判断是不是文件项。5、获取文件的名称，然后输入到对应的目录下，删除临时文件。12345678910111213141516171819202122232425262728293031323334@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test(HttpServletRequest request) throws Exception &#123; //使用fileupload组件完成文件上传 //上传的位置 String realPath = request.getSession().getServletContext().getRealPath("/uploads/"); //判断，该路径是否存在 File file = new File(realPath); if(!file.exists()) file.mkdir();// 解析request对象，获取上传文件项 DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory);// 解析request List&lt;FileItem&gt; items = upload.parseRequest(request);// 遍历 for(FileItem fileItem:items)&#123; //进行判断，当前item对象是否是上传文件项。 if(!fileItem.isFormField())&#123; //不是普通表单项 //获取上传文件的名称 String filename = fileItem.getName();// 完成上传 fileItem.write(new File(realPath,filename));// 删除临时文件 fileItem.delete(); &#125; &#125; return "success"; &#125;&#125; 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2019/6/30 Time: 0:09 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;文件上传&lt;/h3&gt;&lt;form action="con/test" method="post" enctype="multipart/form-data"&gt; 选择文件：&lt;input type="file" name="upload"&gt;&lt;br&gt; &lt;input type="submit" value="上传"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 框架实现文件上传 原理这里我们自己去配置一个文件解析器，然后可以直接在controller里面获取文件上传项。这里参数中的upload必须和input上传文件标签中的upload是一样的。 主要代码，我们只需要修改上面的springMVC.xml文件就可以了，这里添加了一个bean，这里的id必须是multipartResolver 123&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;/bean&gt; controller类 123456789101112131415161718192021@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test(HttpServletRequest request, MultipartFile upload) throws Exception &#123; //使用fileupload组件完成文件上传 //上传的位置 String realPath = request.getSession().getServletContext().getRealPath("/uploads/"); //判断，该路径是否存在 File file = new File(realPath); if(!file.exists()) file.mkdir(); //获取文件的名字 String fileName = upload.getOriginalFilename(); //把文件的名字设置成唯一值 String uuid = UUID.randomUUID().toString().replace("-","");W fileName = uuid+"_"+fileName; // 完成上传 upload.transferTo(new File(realPath,fileName)); return "success"; &#125;&#125; 这里只是解析和上传的时候和之前不太一样。 6、 异常处理 编写自定义异常类（做提示信息） 编写异常处理器 配置异常处理器（跳转到提示页面）主要代码自定义异常类 12345678910111213141516package com.spring.exception;public class SysException extends Exception &#123; private String message; public SysException(String message) &#123; this.message = message; &#125; @Override public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 异常处理器，这里的ex就是接收抛出的异常，利用ModelAndView跳转页面。 123456789101112131415161718192021222324package com.spring.resolver;import com.spring.exception.SysException;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class SysResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; SysException e = null; if(ex instanceof SysException)&#123; e = (SysException) ex; &#125;else&#123; e = new SysException("系统正在维护"); &#125; ModelAndView mv = new ModelAndView(); mv.addObject("errorMsg",e.getMessage()); mv.setViewName("error"); return mv; &#125;&#125; 测试类：通过throw向上抛出异常。 12345678910111213141516171819202122232425package com.spring.controller;import com.spring.exception.SysException;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import java.util.UUID;@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test() throws Exception&#123; try &#123; int a = 10 / 0; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new SysException("出错了....."); &#125; return "success"; &#125;&#125; 配置处理器springMVC.xml配置文件 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "&gt; &lt;context:component-scan base-package="com.spring"&gt;&lt;/context:component-scan&gt;&lt;!--视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置异常处理器--&gt; &lt;bean id="sysResolver" class="com.spring.resolver.SysResolver"&gt;&lt;/bean&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; 运行结果点击后 7、拦截器原理 类似于Servlet开发中的过滤器Filter，用于对处理器（controller）进行预处理和后处理。用户可以自己定义一些拦截器来实现特定的功能。 拦截器链就是将拦截器按一定顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器和过滤器的区别 过滤器是servlet规范中的一部分，任何java web工程都可以使用。 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能用。 过滤器在url-pattern中配置了/*之后，可以对所有要访问的资源所拦截。 拦截器只会拦截访问的控制器方法，如果访问的是jsp，html，css，image或者js是不会进行拦截的。自定义拦截器的步骤第一步，编写一个普通类实现HandlerInterceptor接口 123456789101112131415package com.spring.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Interceptor implements HandlerInterceptor &#123; //预处理，controller方法执行之前，return 为true是放行执行下一个拦截器，如果没有，执行controller中的代码 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("interceptor的preHandle执行了"); return true; &#125;&#125; 第二步，配置拦截器springMVC.xml 1234567891011&lt;!-- 配置异拦截器--&gt; &lt;mvc:interceptors&gt;&lt;!-- 配置具体的拦截器--&gt; &lt;mvc:interceptor&gt;&lt;!-- 具体拦截哪一个方法--&gt; &lt;mvc:mapping path="/con/*"/&gt;&lt;!-- 配置拦截器类--&gt; &lt;bean class="com.spring.interceptor.Interceptor" /&gt;&lt;!-- 不要拦截哪个方法--&gt;&lt;!-- &lt;mvc:exclude-mapping path=""/&gt;--&gt; &lt;/mvc:interceptor&gt; 运行结果 HandlerInterceptor其余的三个方法上述将了第一个方法这里再次回顾一下 preHandle方法是controller方法执行前拦截的方法 可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有就执行controller中的方法。 return false不放行，不会执行controller中的方法。 postHandle方法是controller方法执行后执行的方法，在jsp视图执行前可以使用request或者response跳转到指定的页面如果制定了跳转页面，那么，controller方法跳转的页面将不会显示 afterCompletion方法在jsp执行后执行rerequest或者response不能跳转到指定的页面配置多个拦截器在创建一个拦截器类。然后配置，这里的执行顺序是Interceptor的preHandle –&gt; Interceptor1的preHandle –&gt; controller方法 —&gt;Interceptor1的postHandle –&gt; Interceptor的postHandle –&gt;Interceptor1的afterCompletion –&gt; Interceptor的afterCompletion123456789101112&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/con/*"/&gt; &lt;bean class="com.spring.interceptor.Interceptor" /&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/con/*"/&gt; &lt;bean class="com.spring.interceptor.Interceptor1" /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>springMVC</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于springMVC的运行过程的理解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%AF%B9%E4%BA%8EspringMVC%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天又复习了一下springMVC的框架，又看了书上的解释，现在对springMVC运行原理做点总结，说的不好，请大佬们不要介意。 啥是springMVC？ Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不会直接处理请求。而是调用业务层的方法进行处理，而业务层调用持久层，通过Spring的依赖注入功能，这些bean被注入到控制器中。 springMVC是SSM中的s之一。springMVC中的组件 1、DispatcherServlet为前端控制器，它的作用相当于CPU，一切的工作活动都由这个前端控制器来控制。所有的请求都有经过它来统一分发。 2、HandlerMapping 为处理器映射器，为用户请求的url，能够完成客户请求到Controller映射。 。 3、HandlerAdapyer 为处理器适配器，找到对应controller。 4、ViewResolver 为视图解析器解析View对象，返回给前端的视图页面。springMVC原理图 springMVC的真正内部执行过程是这样的。web.xml DispatcherServlet是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项：（1）截获符合特定格式的URL请求。（2）初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。（3）初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。 对应web.xml文件 12345678910111213141516171819202122&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!-- 配置servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 加载SpringMVC配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 在启动tomcat的时候，服务器解析web.xml中的文件，取到前端控制器dispatcherServlet，其实前端控制器就是一个servlet，这里servlet-mapping标签配置的是我们前端控制器要拦截的的路径，这里的/表示所有的路径。init-param标签里面是需要初始化的文件，这里就初始化了springMVC.xml这个配置springMVC的文件。 一般我们还在web.xml中加入解决中文乱码的配置文件 12345678910111213&lt;!-- 解决中文乱码--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; springMVC.xml这个文件12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "&gt;&lt;!-- 扫描对应的包--&gt; &lt;context:component-scan base-package="com.spring"&gt;&lt;/context:component-scan&gt;&lt;!-- 视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;/bean&gt;&lt;!-- 映射处理器--&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping" abstract="true"/&gt;&lt;!-- 处理器适配器--&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter" abstract="true"/&gt; &lt;mvc:annotation-driven /&gt;&lt;!-- 静态资源--&gt; &lt;mvc:resources mapping="/css/*" location="resources/css/"/&gt; &lt;mvc:resources mapping="/js/*" location="resources/js/"/&gt; &lt;mvc:resources mapping="/images/*" location="resources/images/"/&gt;&lt;/beans&gt; 第一个点：扫描对应的包context:component-scan，以完成Bean创建和自动依赖注入的功能 。这里利用了spring的注入，注解注入。 第二个点：bean id=”internalResourceViewResolver” 视图解析器，用于渲染页面返回页面，第一个property指的是对应的文件夹下，第二个代表后缀。 mvc:annotation-driven 为开启springMVC框架的注解的支持-。 mvc:resources为配置静态资源，那些静态资源可以通过。在加载springMVC文件的时候这些都解析了。只要来一个请求就会直接执行。Controller 1234567891011121314151617package com.spring.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.UUID;@Controller@RequestMapping(path = "con")public class controller &#123; @RequestMapping(path = "test") public String test() t &#123; return "success"; &#125;&#125; 根据路径来执行每个方法。然后返回一个success.jsp，这里就经过了视图解析器，最终稿返回到前端页面（客户端）。]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>springMVC</tag>
        <tag>运行原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js原型链的世界]]></title>
    <url>%2F2019%2F08%2F02%2Fjs%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[js的继承关系不同意搞懂，原型链傻傻不明白，今天用通俗易懂的讲解和例子为大家呈现最简单的原型链理解。 原型链是什么鬼？能干啥？ 每一个类都有一个原型，而这个原型和对象实例之间又有十分微妙的关系。例如：下面的创建对象的代码。 1234function Person(name)&#123; this.name = name;&#125;var person = new Person("nan"); 实际上在函数的内部执行了这个：这里的注释部分实际上就是我们创建对象的时候，执行的函数，也是有返回值的。所以并不是用函数（类）创建对象就没有返回值。 12345678function Person(name)&#123; //var this = &#123; // __proto__:Person.prototype // &#125; this.name=name; // return this &#125; var person = new Person("nan"); 不知道大家看懂了没，注释部分是浏览器内部执行的，我们不需要写，这个是原理，而proto这个是对象的属性，跟我们平常用的是一样的，他也是和这个this.name之后的结果是平级的，都存储在this对象中。而Person.prototype就是我们所说的原型，这是一个对象，隶属于类的对象。 12345678function Person(name)&#123; //var this = &#123; // __proto__:Person.prototype， // name:"nan" // &#125; // return this &#125; var person = new Person("nan"); 而原型链就是很多个原型，形成的链式结构，先看一个代码： 12345678910111213141516Grand.prototype.lastname = "heihei";function Grand()&#123; this.say = 'en';&#125;var grand = new Grand();Father.prototype = grand;function Father()&#123; this.name = "hh" &#125;var father = new Father();Son.prototype = father;function Son()&#123; this.hobbit = "smoke" &#125;var son = new Son();console.log(son) 控制台结果结果： 这就是我们的链式结果，大家先了解，我们在下面会详细介绍这部分知识。 原型链的主要功能是体现在js对象的继承方面上的。 简单回顾下构造函数,原型和实例的关系：每一个构造函数（也就是咱们名字大写的函数function F(){}）都有一个原型对象（prototype）,原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.。 js对象有这么个有趣的规则:如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性。理解原型链 这里就以上面的代码为例：同时大家要明确，原型链脱离对象是没意义的。 如果每一个原型含有相同的属性名，那也是可以的，不过，任何方法在查找属性都是从son对象开始查找，看看有没有这个属性，如果有的话直接获取，没有再依次查找father、grand直到遍历完原型链。 至于这里为什么proto都叫Grand，是由于最上层是Grand.prototype中的contructor构造器是Grand__proto__和prototype的关系 proto属于对象属性，里面含有的是类.prototype，prototype是类属性。 例如： 1234function Person()&#123;&#125; var person = new Person(); console.log(person.__proto__ == Person.prototype); 这里是相同的，而且形成原型链的时候可以指定Person.prototype的对象。实际原型链分析1、简单类型 1234567891011Person.prototype = &#123; name : 'a', sayName : function()&#123; console.log(this.name) &#125;&#125;function Person()&#123; this.name = 'b';&#125;var person = new Person();person.sayName(); 1234567891011Person.prototype = &#123; name : 'a', sayName : function()&#123; console.log(this.name) &#125;&#125;function Person()&#123; // this.name = 'b';&#125;var person = new Person();person.sayName(); 将Person中的this.name注释掉，发现就是输出的是原型的值，这也再次验证了上面说的，对象查找属性是从原型链开始查找的，逐步向上查找。2、复杂类型12345678910111213141516171819Grand.prototype.lastname = "heihei";function Grand()&#123; this.say = 'en';&#125;var grand = new Grand();Father.prototype = grand;function Father()&#123; this.name = "hh" &#125;var father = new Father();Son.prototype = father;function Son()&#123; this.hobbit = "smoke" &#125;var son = new Son();console.log(son.hobbit);console.log(son.name);console.log(son.say);console.log(son.lastname); 这样也再再次验证了。利用实现对象的继承 实际上上述的例子就实现了上面的对象继承，但是对于这种情况：无法实现传参。 123456789101112Person.prototype.info = function()&#123; console.log("name:"+this.name+",age"+this.age+",grade:"+this.grade); &#125; function Person(name,age)&#123; this.name = name; this.age = age; &#125; Student.prototype = new Person(); function Student(name,age,grade)&#123; this.grade = grade &#125; var stu = new Student("戴",20,11); 这里的name和age都没有传入进去。我们可以输出一下。 1console.log(stu); 这里面的值都是undefined。有的人喜欢这样去修改。 123456789101112131415Person.prototype.info = function()&#123; console.log("name:"+this.name+",age"+this.age+",grade:"+this.grade); &#125; function Person(name,age)&#123; this.name = name; this.age = age; &#125; Student.prototype = new Person(); function Student(name,age,grade)&#123; this.grade = grade &#125; var stu = new Student(11); stu.name = "戴"; stu.age = 20; stu.info(); 第一眼看来，这是正确的，但是实际上这里个问题就是麻烦，不符合正常的面向对象的构造对象的步骤，繁琐。1console.log(stu) 这里实际上是再stu对象中，增加了两个实例属性。这也是不符合我们的要求的，我们想的是覆盖undefined。 最终继承代码，也是最牛叉的。 12345678910111213141516Person.prototype.info = function()&#123; console.log("name:"+this.name+",age"+this.age+",grade:"+this.grade); &#125; function Person(name,age)&#123; this.name = name; this.age = age; &#125; Student.prototype = new Person(); function Student(name,age,grade)&#123; Person.call(this,name,age); // Person.apply(this,[name,age]) this.grade = grade &#125; var stu = new Student("戴",20,11); stu.info(); console.log(stu); 利用了一个call或者apply就可以实现。最后一个例子（利于理解） 12345678910111213141516171819202122232425262728293031function Animal(age,sex)&#123; this.sex = sex; this.age = age; this.info = function()&#123; console.log("年龄:"+this.age+",性别:"+this.sex); &#125; &#125; Dog.prototype = new Animal(); function Dog(name,age,sex)&#123; this.name = name; Animal.call(this,age,sex); this.bark = function()&#123; console.log(this.name+"的叫声wangwangwang"); &#125; &#125; var dog = new Dog("hsq",2,'m'); dog.info(); dog.bark(); Cat.prototype = new Animal(); function Cat(name,age,sex)&#123; this.name = name; Animal.call(this,age,sex); this.bark = function()&#123; console.log(this.name+"的叫声miaomiaomiao"); &#125; &#125; var cat = new Cat("bsm",2,'f'); cat.info(); cat.bark();]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>原型链</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂的js闭包]]></title>
    <url>%2F2019%2F08%2F01%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84js%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包在js中是非常重要的一部分，也是可以说最难的一部分，这篇文章讲带你去理解闭包与、作用域链、执行期上下文的关系，带你去理解js中查找查找变量的底层原理。 1、闭包是什么鬼？ 当内部函数被保存到了外部时，将会生成闭包。闭包会导致原有的作用域链不释放，造成内存泄露。 如果i不知道作用域链是什么鬼，那么请看前两篇。12345678function outer()&#123; function inner()&#123; &#125; return inner;&#125;var demo = outer();demo(); 2、闭包是这么个东西 首先，在执行var demo = outer();之前（这个是一个函数调用），outer函数产生了一个执行期上下文，产生了一个作用域链。 执行后将inner函数给到了demo 1var demo = function inner()&#123; &#125; 再次执行的demo();之前，inner本身产生了一个执行期上下文，和一个新的作用域链，outer()。执行完他的作用域链就消失了。 最后执行，执行函数。3、举个栗子示例1123456789101112function add()&#123; var count = 0; function demo()&#123; count++; console.log(count); &#125; return demo;&#125;var counter = add();counter();counter();counter(); 如果不知道闭包这个概念，一定会认为是输出三个1； 我们来分析一下三个 counter()；第一个执行，这里通过count++，加加到作用域链中。输出1 然后执行 counter()，这里的 数据再次加一，之前说过，函数中所有查找变量和对数据的操作都是查找的作用域链。 同理，第三次。示例2123456789101112131415function test()&#123; var num = 100; function a()&#123; num++; console.log(num); &#125; function b()&#123; num--; console.log(num); &#125; return [a,b];&#125;var c = test();c[0]();c[1](); 这个和第一题也是同理示例3 1234567891011121314function eater()&#123; var food = ""; function a()&#123; console.log("i am eating" + food); food = ""; &#125; function b(myfood)&#123; food = myfood; &#125; return [a,b]; &#125; var eater1 = eater(); eater1[1]('banana'); eater1[0](); 这里的例子展示的是两个函数，两个作用域链，互不干扰。示例4 1234567891011121314function test()&#123; var arr = []; for(var i = 0;i &lt; 10;i++)&#123; arr[i] = function ()&#123; console.log(i + " "); &#125; &#125;; return arr; &#125; var myarr = test(); for(var j = 0;j &lt; 10;j++) &#123; myarr[j](); &#125; 如果不知道执行期上下文、作用域链、闭包的童鞋们一定会认为是输出0 - 9，但是结果： 我们来分析一下：这里面的for循环执行完之后是这样的i = 10；这里的要点在于arr[i] = function (){ }，这里输出的i是查找作用域链中的，在for循环中无法确定里面的值。作用域链： 更改代码为： 123456789101112131415function test()&#123; var arr = []; for(var i = 0;i &lt; 10;i++)&#123; (function (j)&#123; arr[j] = function ()&#123; document.write(j + " "); &#125; &#125;(i)); &#125; return arr;&#125;var myarr = test();for(var j = 0;j &lt; 10;j++)&#123; myarr[j](); &#125; 运行结果： (function(){})在test和arr[i]之间多加了一层的作用域。这样就可以正常输出了。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>作用域链</tag>
        <tag>scope</tag>
        <tag>执行期上下文</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js底层原理作用域和作用域链]]></title>
    <url>%2F2019%2F07%2F31%2Fjs%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[前几天刚刚整理的 JavaScript预编译（执行期上下文），这里需要提前明白上一篇文章，这篇文章也是为闭包铺垫理论知识。 1、作用域（[[scope]]） [[scope]]：每一个js函数都是一个对象，对象中有些属性我们可以访问，但是有些不可以，这些属性仅供js引擎存取，[[scope]]就是其中的一个。[[scope]]指的是我们所说的作用域（作用域链），其中存储了运行期期上下文的集合。每一个函数都有一个作用域。 运行期上下文：当函数执行的过程之前，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行对应执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行期上下文会被销毁。 看不懂概念不要紧，可以看下面的例子，然后看概念就会理解。 如果不知道执行期上下文的可以看：第二篇：JavaScript预编译（执行期上下文）2、作用域链 [[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。3、要知道 12345function Person()&#123;&#125;console.log(Person.name);console.log(Person.prototype); 这里的Person.name等就是可以访问的，但是Per’son.[[scope]]就是我们访问不到的。 这里每次调用都会产生一个新的AO对象。12345function test()&#123; &#125;test() -&gt; 产生一个AO&#123;&#125; 用完销毁test() -&gt; 产生一个AO&#123;&#125; 用完销毁 3、例子123456789function a()&#123; function b()&#123; var b = 234; &#125; var a = 123; b();&#125; var glob = 100; a(); a函数定义时，产生了一个[[scope]]，这里实际上只有一个GO，全局的作用域。 a在要执行之前，产生了一个执行期上下文。在这里，新创建的AO是作用域的顶端，我们在查找变量的时候就是沿着作用域链去查找变量，从顶端开始。这也就是为什么，在函数调用时，先查找自己是否含有这个属性，如果没有这个属性就去父级查找，这就是原理。这就是a函数的作用域链了。可以理解为[[scope]]为一个数组。函数本身的预编译形成AO永远是放在最顶端。 由于a函数的执行内部执行b()，所以b函数只在执行之前又产生了一个执行期上下文。所以b的作用域链直接基于a的作用域链。 b函数被创建时的作用域环境： b()执行之前进行预编译，形成的作用域链。 当b函数查找变量的时候，自顶向下查找变量。这里是为下一篇闭包铺垫理论知识。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>作用域链</tag>
        <tag>scope</tag>
        <tag>执行期上下文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS权重]]></title>
    <url>%2F2019%2F07%2F31%2FCSS%E6%9D%83%E9%87%8D%2F</url>
    <content type="text"><![CDATA[css在设置样式的时候，存在优先级的问题，比如设置了两个背景颜色，那么真正显示的究竟是哪一种颜色呢？ 一、问题提出？请问div的背景颜色为红色还是绿色呢？ 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="background-color: green;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 答案为绿色。为什么会是绿色呢？难道存在代码执行的先后的覆盖问题？请看第二个问题。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; &#125; #demo1&#123; background-color: red; &#125; .demo2&#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo2" id="demo1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; div的颜色为红色。当设置背景颜色的代码互换后div的背景颜色依然是红色。这说明并不是覆盖问题，读者可以自己试一试。 123456.demo2&#123; background-color: green;&#125;#demo1&#123; background-color: red;&#125; 二、问题的解释在css的样式中存在权重，权重最高的执行相关的代码。权值是256进制。| 相关属性 | 权值 | 相关样例 ||–|–|–|| !important | Infinity | #only{background-color: yellow!important;} ||行间样式|1000| p style = “” /p || id | 100 | #demo{} ||class、属性、伪类|10|.demo{} 、 、a:hover{}|| 标签、伪元素 | 1| div{} 、::after{} ||通配符|0|*{}|第一个问题中，由于行间样式的权值要比内联样式的权值要高，所以执行行间样式的代码。第二个问题中，由于id的权值要比class权值高，所以执行id的代码。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>css权重</tag>
        <tag>css优先级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[史上最好理解的Unicode编码讲解（Unicode的前世今生）]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%90%86%E8%A7%A3%E7%9A%84Unicode%E7%BC%96%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88Unicode%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[关于Unicode的由来，以及与utf-8、utf-16的关系、原理、计算、编码和解码。用最通俗易懂的方法讲解。 一、了解编码 在计算机中存储的数据都是01二进制的数据串，我们再电脑屏幕上看到的一切可视化的东西最终在计算机存储的都是01二进制串，现在看到我博客上的文字也是。 这里就需要一个映射关系，将我们看到的看到的字符、图片、视频转换成对应的二进制，存储到计算机中，以便于计算机能够识别。这就是我们要将的编码。 图片和视频首先会转换成字符流，然后按照编码转换成字节流，存储到计算机中。 举一个例子：在ASCLL码表中，字符’a‘对应的是97，二进制是01100001，如果我们在编辑器或者其他软件中输入字母a，按键盘a，那么输入法就会告诉操作系统，在计算机中调用97，然后就会显示a字符。 也就是说编码表在我们在计算机屏幕看到的数字和计算机底层之间架起了一个桥梁。至关重要！ 二、编码的历程1、开始 最早出现的是ASCLL码，是由美国人制定的，这种编码采用的是1个字节表示一个字符，也就是一个字符是八个二进制位，这里一共可以表示256个字符。起初，表示英文中所有的字符一共用了128位字符。事实上还剩下了一百多个字符空间。这128个字符中包含了数字、字母以及常用字符，例如：A是65，对应的二进制数为0100 0001。而且呢，这个128个字符只用了八位二进制数中的后七位，最前面的一位统一为0。 2、问题初现 但是很快就暴露出了问题，这128个字符表示英文没有任何问题，但是要是表示其他国家的语言就不够了。率先是欧洲决定利用起来前一位，这样就可以表示256个字符了，而紧接着又出现了一个问题，就是不同国家的同一个码点（八位二进制数）表示的符号可能不同，例如144 在阿拉伯人的 ASCII 码中是 گ，而在俄罗斯的 ASCII 码中是 ђ。 所以呢，最后人们在0-127号字符上面达成了一致，对于128 - 255号字符就尽情发挥了，这时候的码点还是一个字节。 3、再遇到波折 随着计算机的兴起，传入亚洲国家，亚洲国家有更多的字符需要存储，这样256个字符就放不下这些符号了，这时候人们决定用两个字节一共十六位，最多可以表示65535个字符。来存储全世界的字符。但是此时各个国家的编码还是不一样的。如ASCII、GB2312等。 4、程序员的噩梦 各种各样的编码方式成了系统开发者的噩梦，因为他们想把软件卖到国外，但是由于编码不同，一台计算机根本无法表示所有国家的编码。于是，他们提出了一个“内码表”的概念，可以切换到相应语言的一个内码表，这样才能显示相应语言的字母。在这种情况下，如果使用多语种，那么就需要频繁的在内码表内进行切换。这样依然很麻烦。 5、解决 最终，美国人决定设计一种标准方案来展示世界上所有语言中的所有字符，Unicode诞生了。Unicode 给所有的字符指定了一个数字用来表示该字符。规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。它的想法很简单，就是为每个字符规定一个用来表示该字符的数字，仅此而已。具体是怎样的对应关系，又或者说是如何进行划分的，就不是我们考虑的问题了， 三、Unicode 编码方案 Unicode 当然是一本很厚的字典，记录着世界上所有字符对应的一个数字。以汉字“汉”为例，它的 Unicode 码点是 0x6c49，对应的二进制数是 110110001001001，二进制数有 15 位，这也就说明了它至少需要 2 个字节来表示。可以想象，在 Unicode 字典中往后的字符可能就需要 3 个字节或者 4 个字节。 1、空间浪费？ 大家可以试想一下，有的字符需要两个字节、有的需要三个四个字节，那计算机如何去分辨该字节是几个字节的字符呢？大家第一个想到的可能是全部采用4个字节的编码，毕竟这个可以表示上亿个字符了。但是如果一个美国的新闻发布网站，全英文表示（前面已经说了代码单元也就是存储为一个字节就可以表示所有的英文字符），现在前面三个字节都是0，文件大小变成了之前的四倍或者三倍，这样浪费掉了大量的存储空间。 2、UTF系列编码什么鬼？ 为了较好的解决 Unicode 的编码问题， UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了。当然还有一个 UTF-32 的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，但是一般的字符两个字节就可以轻松解决了，只有一些其他小国家的特殊字符才采用UTF-32编码。 3、UTF-8编码 UTF-8 是一个非常惊艳的编码方式，漂亮的实现了对 ASCII 码的向后兼容，以保证 Unicode 可以被大众接受。 UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下： 对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。 对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。 编码规则如下： Unicode 十六进制码点范围 UTF-8 二进制 0000 0000 - 0000 007F 0xxxxxxx 0000 0080 - 0000 07FF 110xxxxx 10xxxxxx 0000 0800 - 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 - 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 4、插入一只广告 这里的除x外都是控制位，真正的表示位的只是x，第一个字节0xxxxxxx，可以容纳7个二进制位，第二个可以容纳11个二进制位，以此类推，然后计算左边的范围。 5、编码与解码 根据上面编码规则对照表，进行 UTF-8 编码和解码就简单多了。下面以汉字“汉”为利，具体说明如何进行 UTF-8 编码和解码。“汉”的 Unicode 码点是 0x6c49（110 1100 0100 1001），通过上面的对照表可以发现，0x0000 6c49 位于第三行的范围，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 11100110 10110001 10001001，转换成十六进制就是 0xE6 0xB7 0x89。 解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节。 UTF-16编码 在了解 UTF-16 编码方式之前，先了解一下另外一个概念——“平面”。 在上面的介绍中，提到了 Unicode 是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（2^16）字符，称为一个平面（plane）。目前，一共有 17 个（2^5）平面，也就是说，整个 Unicode 字符集的大小现在是 2^21。 最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 2^16-1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 U+010000 到 U+10FFFF。 基本了解了平面的概念后，再说回到 UTF-16。UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？ 这里有一个很巧妙的地方，在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。 辅助平面的字符位共有 2^20 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。 接下来，以汉字”𠮷”为例，说明 UTF-16 编码方式是如何工作的。 汉字”𠮷”的 Unicode 码点为 0x20BB7，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 0x20BB7 - 0x10000 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为0001000010 1110110111。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。U+D800 对应的二进制数为 1101100000000000，直接填充后面的 10 个二进制位即可，得到 1101100001000010，转成 16 进制数则为 0xD842。同理可得，低位为 0xDFB7。因此得出汉字”𠮷”的 UTF-16 编码为 0xD842 0xDFB7。 Unicode3.0 中给出了辅助平面字符的转换公式： 123H = Math.floor((c-0x10000) / 0x400)+0xD800L = (c - 0x10000) % 0x400 + 0xDC00 根据编码公式，可以很方便的计算出字符的 UTF-16 编码。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>unicode编码</tag>
        <tag>uft-8编码</tag>
        <tag>uft-16编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于浮点数丢失精度的原理]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%85%B3%E4%BA%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浮点数会存在精度丢失的现象，大很多金融的大项目中，都不去使用浮点数。因为这个数很危险，我们可以剖析一下原理。 1、前言首先我们必须要清楚 在计算机中所有的数值、代码、信息都是以01二进制存储的，也就是说我们输入的所有信息，最终都会表示成01二进制的形式。例如byte类型的 0000 1000表示的是整数8。然后我们要清楚 所有的整数类型转换成二进制，看如下代码： 12345//表示11的二进制数计算11 / 2 = 5 余 1 --&gt; 15 / 2 = 2 余 1 --&gt; 12 / 2 = 1 余 0 --&gt; 0 1 / 2 = 0 余 1 --&gt; 1 所有的小数转换成二进制：看如下代码： 1234567//0.1转换为二进制0.1 * 2 = 0.2 --&gt;00.2 * 2 = 0.4 --&gt;00.4 * 2 = 0.8 --&gt;00.8 * 6 = 1.6 --&gt;1//然后去掉10.6 * 2 = 1.2 --&gt;10.2 * 2 = 0.4 --&gt;0 这个是一直循环下去的，所以呢计算机无法精确表示0.1，这个数值而是无限接近近似表示。 所以11的二进制数是1011，这样开来所有的整数最后都会被1 / 2 = 0这样结束。 2、我们先来看这样的一段代码12345double dou = 234533464.456576564675d;System.out.println("234533464.456576564675的运行结果："+dou);float f = 997979759f;System.out.println("997979759的运行结果："+f);System.out.println("0.1+0.2的运行结果："+(0.2 + 0.1)); 结果是： 惊奇不惊奇，刺激不刺激？这种采用浮点数的方法，输出的结果就是错误的。前两位后面的精度丢失，最后一个表示的不准确。 同样再看另外一段代码123456float f1 = 20014999; double d1 = f1; double d2 = 20014999; System.out.println("f=" + f1); System.out.println("d=" + d1); System.out.println("d2=" + d2); 运行结果： 又是满满的疑问123double a = 0.3d;System.out.println(0.2d+0.1d);System.out.println(a); 我估计第三个直接刷新了好多人的三观，为啥直接存储就输出正确，运算就出错了呢？接下来我就围绕这几个问题对对大家一一解答。3、我们先了解一下浮点数在计算机中是如何存储的。 float（32位浮点数）在计算机中的表示形式。 浮点数存储都遵守IEEE754标准，具体的运算应该在计算机组成原理中会重点介绍，标准如下： 其中S表示该浮点数的正负，E代表阶码，M代表的是尾数。 一个十进制数可以表示为 : 例如：20.59375在计算机中存储为： 20.59375 = 10100.10011，这里的s = 0，E = 4 + 127 = 131 ，M = 01001001； 所以存储格式为0100 001 1010 0100 1100 0000 0000 0000。这里就是存储在计算机中的数据。 至于为什么要加127，这个是IEEE754标准规定的，但是在维基百科以及其他文献中也并没有直接说为什么是这样。 double（64位浮点数）在计算机中的表示形式。 同理这个和上面的是一样的。 实际上这个1.M表示的是比如1000.111这个数，小数点移动位为1.000111，在754标准下存储为000111位数，这么做相当于是能够多保存一位，所以float可以保存的尾数是24位（23），double为53位而不是（52）。4、我们首先来解决第二个问题 123float f1 = 20014999; double d1 = f; double d2 = 20014999; 刚才不是说所有的整数都不会丢失精度吗，这个这么不一样呢。这个实际上也是因为float保留的位数太小造成的。 我们来分析一下：先输出他们的二进制位数 123456789float f1 = 20014999; double d1 = f1; double d2 = 20014999;long l1 = Float.floatToIntBits(f1);long l2 = Double.doubleToLongBits(d1);long l3 = Double.doubleToLongBits(d2);System.out.println("f1=" + Long.toBinaryString(l1)); System.out.println("d1=" + Long.toBinaryString(l2)); System.out.println("d2=" + Long.toBinaryString(l3)); 这里遵循IEEE754标准，但是注意这里面没有符号位，这三种结果为什么不同，我们这就分析，首先我告诉大家d2的输出结果是正确的。其中前11位是阶码1000 0010 111= 1047，后面的0011 0001 0110 0111 1001 0111 0000 0000 0000 0000 0000 0000 0000便是尾数，所以1047 - 1023 = 24，所以这个数真正的结果就是（别忘了1.M）：1.0011 0001 0110 0111 1001 0111然后小数点向右移动24位，就是10011 0001 0110 0111 1001 0111 = 20014999； 我们再来看第一个我们对比着尾数1.00110001011001111001100就会发现这里的尾数要比1.001100010110011110010111少了一位，而且少的一位是1，所以进行舍入处理，进行进位变成了1.00110001011001111001100。这样就产生了误差。也就变成了20015000。大家要清楚这里不光是尾数的位数少了还有相应的进位处理。同时要记得这里面float只能保存24位小数，double可以保留53位。 第二个就不用说了，由于本身f是错的，所以呢，赋值给d1之后仍然是是错的。 第三个由于54尾尾数可以放得下该数值的二进制数，所以是正确的。 到此为止呢，大家要明确一个概念就是，如果保存的浮点数超过了，该类型的最大精度，那么就会产生是很大很严重的问题，而且存入计算机中就会是存储的错的。明确这一点之后也就产生了我们第三个问题（非常奇怪的问题），所以呢我们最后来说这个问题。5、解决第一个问题。 讲过第二个问题之后，第一个问题就非常好理解了，我们通过IEEE754的算法，可以得到这两个数的二进制表示形式，当用754标准去选取尾数的时候呢，就会截取掉一部分的尾数，造成精度丢失，其实原理是一样的。234533464.456576564675 = 2.34533464456576564675*e8,然后仍然是转换成754标准就失去了一些精度。具体的算法需要朋友们找相关的资料，这里不在赘述。6、最奇怪的问题第三个问题。1234567double a = 0.1d;double b = 0.2d;double c = a + b;System.out.println(a+&quot;的二进制数:&quot;+Long.toBinaryString(Double.doubleToLongBits(a)));System.out.println(b+&quot;的二进制数:&quot;+Long.toBinaryString(Double.doubleToLongBits(b)));System.out.println(c+&quot;的二进制数:&quot;+Long.toBinaryString(Double.doubleToLongBits(c)));System.out.println(0.3+&quot; 的二进制数:&quot;+Long.toBinaryString(Double.doubleToLongBits(0.3d))); 大家可以看到直接存储的0.3和计算之后出现的（数学上来说的0.3）在计算机中保存的二进制编码是不同的，原因就在于首先计算机中无法精确表示0.1和0.2，所以实际上a，b并不是真正的0.1和0.2，已经出现了误差，所以相加之后计算出来的值就是错的，也就是0.30000000000000004。那至于为什么能够出现直接存储就可以正常显示呢，是由于编译器优化的结果，在不计算的情况下，可以正常显示，但是没有任何意义，因为一旦参与计算或者比较大小，那么这个值就不代表数学意义上的0.1了。]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>浮点数精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript预编译（执行期上下文）]]></title>
    <url>%2F2019%2F07%2F28%2FJavaScript%E9%A2%84%E7%BC%96%E8%AF%91%EF%BC%88%E6%89%A7%E8%A1%8C%E6%9C%9F%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[很多人前端人员都知道变量提升这个概念，但是为什么会出现这样，很多人模棱两可。实际上在js中这叫做预编译，也叫做执行期上下文，在这里深度剖析一下它的底层原理。 预编译（又叫“执行期上下文”）一般来说，预编译与闭包、作用域链和闭包是密切相关的，好多人包括在企业开发的人都听说过一句话叫做变量提升和“函数声明整体提升”。这个就是预编译后的一个小结果，所以今天自己总结了一下。分为以下几个步骤来说。 大家先看看这段代码12console.log(a);var a = 1; 为什么变量的声明在输出的下面，却没有报错？值为什么是undefined？ 大家再看看下面这段代码1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; function test(a,b)&#123; console.log(a); var a = 'demo'; console.log(a); function a()&#123;&#125; console.log(a); var a = function ()&#123;&#125; console.log(a); console.log(b) var b = 1; &#125; test(1);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 大家看到这段代码是不是很震惊呢？形参、变量名、函数名都是“a”，那么输出的结果会是怎样呢？ 和大家想的一样吗？大家心里是不是有这么几个问题，前四个输出的都是a，为什么输出的结果不一样呢？而且b变量不是把1赋值给它了吗，为什么会是undefined？接下来咱们来讲讲什么是预编译（执行期上下文）。到最后大家就明白了。 预编译（‘执行期上下文’）预编译发生在函数执行之前。划重点了啊！！！！！ 这句话很重要，函数执行之前也就是在这段程序开始之前，浏览器对马上要执行的函数进行预编译！！预编译四部曲 创建AO对象 找形参和变量声明，将变量和形参作为AO属性名，值为undefined 将实参和形参相统一 在函数体里找到函数声明，值赋予函数体最后程序输出变量值的时候，就是从AO对象中拿。]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>变量提升</tag>
        <tag>预编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>tags1</tag>
        <tag>tags2</tag>
      </tags>
  </entry>
</search>
